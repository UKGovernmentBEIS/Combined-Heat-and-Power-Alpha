//         Project / File: DESNZ.CHPQA.Alpha.Prototype.Services / <filename>.cs
// File generated by: CRM Code Generator - Ahmed Elsawalhy (Yagasoft.com)

using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Xml.Linq;
using System.Text;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Reflection;
using System.ServiceModel;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Query;


namespace DESNZ.CHPQA.Alpha.Prototype.Services
{
	#region XrmServiceContext

	/// <summary>
	/// Represents a source of entities bound to a CRM service. It tracks and manages changes made to the retrieved entities.
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public partial class XrmServiceContext : OrganizationServiceContext
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		public XrmServiceContext(IOrganizationService service) : 
				base(service)
		{
		}

		/// <summary>
		/// Gets a binding to the set of all <see cref="Boiler"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Boiler> BoilerSet
		{
			get
			{
				return this.CreateQuery<Boiler>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="BoilerType"/> entities.
		/// </summary>
		public System.Linq.IQueryable<BoilerType> BoilerTypeSet
		{
			get
			{
				return this.CreateQuery<BoilerType>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Diagram"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Diagram> DiagramSet
		{
			get
			{
				return this.CreateQuery<Diagram>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Fuel"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Fuel> FuelSet
		{
			get
			{
				return this.CreateQuery<Fuel>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="FuelCategory"/> entities.
		/// </summary>
		public System.Linq.IQueryable<FuelCategory> FuelCategorySet
		{
			get
			{
				return this.CreateQuery<FuelCategory>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="FuelType"/> entities.
		/// </summary>
		public System.Linq.IQueryable<FuelType> FuelTypeSet
		{
			get
			{
				return this.CreateQuery<FuelType>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Manufacturer"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Manufacturer> ManufacturerSet
		{
			get
			{
				return this.CreateQuery<Manufacturer>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Meter"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Meter> MeterSet
		{
			get
			{
				return this.CreateQuery<Meter>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="MeterReadings"/> entities.
		/// </summary>
		public System.Linq.IQueryable<MeterReadings> MeterReadingsSet
		{
			get
			{
				return this.CreateQuery<MeterReadings>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="MeterReadingValue"/> entities.
		/// </summary>
		public System.Linq.IQueryable<MeterReadingValue> MeterReadingValueSet
		{
			get
			{
				return this.CreateQuery<MeterReadingValue>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Model"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Model> ModelSet
		{
			get
			{
				return this.CreateQuery<Model>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="PrimeMover"/> entities.
		/// </summary>
		public System.Linq.IQueryable<PrimeMover> PrimeMoverSet
		{
			get
			{
				return this.CreateQuery<PrimeMover>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="PrimeMoverType"/> entities.
		/// </summary>
		public System.Linq.IQueryable<PrimeMoverType> PrimeMoverTypeSet
		{
			get
			{
				return this.CreateQuery<PrimeMoverType>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Scheme"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Scheme> SchemeSet
		{
			get
			{
				return this.CreateQuery<Scheme>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Site"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Site> SiteSet
		{
			get
			{
				return this.CreateQuery<Site>();
			}
		}
		/// <summary>
		/// Gets a binding to the set of all <see cref="Submission"/> entities.
		/// </summary>
		public System.Linq.IQueryable<Submission> SubmissionSet
		{
			get
			{
				return this.CreateQuery<Submission>();
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public class LinqEntityLimiter : ExpressionVisitor
	{
		protected override Expression VisitNew(NewExpression node)
		{
			var constructor = node.Constructor;
			var parameters = constructor.GetParameters();
			var param = node.Arguments.FirstOrDefault();
			var paramType = param?.Type;

			if (paramType != null && constructor.DeclaringType == paramType
				&& parameters.FirstOrDefault()?.ParameterType == typeof(object))
			{
				var valueGetter = paramType.GetMethod("GetAttributeValue", new[] { typeof(string) })?
					.MakeGenericMethod(typeof(object));

				if (valueGetter != null)
				{
					var limiterType = (node.Arguments.Skip(1).FirstOrDefault() as ConstantExpression)?.Value as Type;

					NewArrayExpression keysInit = null;
					NewArrayExpression valuesInit = null;

					if (limiterType == null && (parameters.Length == 1 || parameters.Skip(1).FirstOrDefault()?.ParameterType == typeof(Type)))
					{
						var attributes = paramType.GetProperties().Cast<MemberInfo>().Union(paramType.GetFields())
							.Where(e => Attribute.IsDefined(e, typeof(AttributeLogicalNameAttribute))).ToArray();

						keysInit = Expression.NewArrayInit(typeof(string), attributes
							.Select(e => Expression.Constant(e.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName)));
						valuesInit = Expression.NewArrayInit(typeof(object), attributes
							.Select(e => Expression.Call(param, valueGetter,
								Expression.Constant(e.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName))));
					}
					else if (limiterType != null && typeof(EntityContract).IsAssignableFrom(limiterType)
						&& parameters.Skip(1).FirstOrDefault()?.ParameterType == typeof(Type))
					{
						var attributes = limiterType.GetProperties().Cast<MemberInfo>().Union(limiterType.GetFields())
							.Where(e => Attribute.IsDefined(e, typeof(CrmFieldMappingAttribute))
								&& !Attribute.IsDefined(e, typeof(CrmRelationMappingAttribute))).ToArray();

						keysInit = Expression.NewArrayInit(typeof(string), attributes
							.Select(e => Expression.Constant(e.GetCustomAttribute<CrmFieldMappingAttribute>().LogicalName)));
						valuesInit = Expression.NewArrayInit(typeof(object), attributes
							.Select(e => Expression.Call(param, valueGetter,
								Expression.Constant(e.GetCustomAttribute<CrmFieldMappingAttribute>().LogicalName))));
					}

					if (keysInit != null)
					{
						var constructorInfo = paramType.GetConstructor(new[] { typeof(string[]), typeof(object[]) });

						if (constructorInfo != null)
						{
							return Expression.New(constructorInfo, keysInit, valuesInit);
						}
					}
				}
			}

			return base.VisitNew(node);
		}
	}

	/// <summary>
	/// Credits: https://github.com/davidfowl/QueryInterceptor
	/// </summary>
	public static class QueryableExtensions
    {
        public static IQueryable<T> InterceptWith<T>(this IQueryable<T> source, params ExpressionVisitor[] visitors)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            return new QueryTranslator<T>(source, visitors);
        }
    }

    internal class QueryTranslator<T> : IOrderedQueryable<T>
    {
	    public Type ElementType => typeof(T);
        public Expression Expression { get; }
        public IQueryProvider Provider => provider;

		private readonly QueryTranslatorProvider<T> provider;

        public QueryTranslator(IQueryable source, IEnumerable<ExpressionVisitor> visitors)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            if (visitors == null)
            {
                throw new ArgumentNullException(nameof(visitors));
            }

            Expression = Expression.Constant(this);
            provider = new QueryTranslatorProvider<T>(source, visitors);
        }

        public QueryTranslator(IQueryable source, Expression expression, IEnumerable<ExpressionVisitor> visitors)
        {
	        Expression = expression ?? throw new ArgumentNullException(nameof(expression));
            provider = new QueryTranslatorProvider<T>(source, visitors);
        }

        public IEnumerator<T> GetEnumerator()
        {
            return ((IEnumerable<T>)provider.ExecuteEnumerable(Expression)).GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return provider.ExecuteEnumerable(Expression).GetEnumerator();
        }
    }

    internal abstract class QueryTranslatorProvider : ExpressionVisitor
    {
	    internal IQueryable Source { get; }

		protected QueryTranslatorProvider(IQueryable source)
        {
			Source = source ?? throw new ArgumentNullException(nameof(source));
        }
	}

    internal class QueryTranslatorProvider<T> : QueryTranslatorProvider, IQueryProvider
    {
        private readonly IEnumerable<ExpressionVisitor> visitors;

        public QueryTranslatorProvider(IQueryable source, IEnumerable<ExpressionVisitor> visitors)
            : base(source)
        {
	        this.visitors = visitors ?? throw new ArgumentNullException(nameof(visitors));
        }

        public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
        {
            if (expression == null)
            {
                throw new ArgumentNullException(nameof(expression));
            }

            return new QueryTranslator<TElement>(Source, expression, visitors);
        }

        public IQueryable CreateQuery(Expression expression)
        {
            if (expression == null)
            {
                throw new ArgumentNullException(nameof(expression));
            }

            var elementType = expression.Type.GetGenericArguments().First();
            var result = (IQueryable)Activator.CreateInstance(typeof(QueryTranslator<>).MakeGenericType(elementType),
				Source, expression, visitors);

            return result;
        }

        public TResult Execute<TResult>(Expression expression)
        {
            if (expression == null)
            {
                throw new ArgumentNullException(nameof(expression));
            }

            var result = (this as IQueryProvider).Execute(expression);

            return (TResult)result;
        }

        public object Execute(Expression expression)
        {
            if (expression == null)
            {
                throw new ArgumentNullException(nameof(expression));
            }

            var translated = VisitAll(expression);

            return Source.Provider.Execute(translated);
        }

        internal IEnumerable ExecuteEnumerable(Expression expression)
        {
            if (expression == null)
            {
                throw new ArgumentNullException(nameof(expression));
            }

            var translated = VisitAll(expression);

            return Source.Provider.CreateQuery(translated);
        }

        private Expression VisitAll(Expression expression)
        {
            // Run all visitors in order
            var visitorsQ = new ExpressionVisitor[] { this }.Concat(visitors);
            return visitorsQ.Aggregate(expression, (expr, visitor) => visitor.Visit(expr));
        }

        protected override Expression VisitConstant(ConstantExpression node)
        {
            // Fix up the Expression tree to work with the underlying LINQ provider
	        if (!node.Type.IsGenericType || node.Type.GetGenericTypeDefinition() != typeof(QueryTranslator<>))
	        {
		        return base.VisitConstant(node);
	        }

	        var provider = ((IQueryable)node.Value).Provider as QueryTranslatorProvider;

	        return provider == null ? Source.Expression : provider.Source.Expression;
        }
    }

	#endregion

	#region Extensions

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
    public class ValidationError
    {
        public Guid? RecordId;
        public string AttributeName;

        public ValidationType ErrorType;
        public IDictionary<int, string> ErrorMessage;

        public string StringValue;
        public int? StringMaxLength;

        public decimal? NumericValue;
        public decimal? NumericRangeMin;
        public decimal? NumericRangeMax;
    }

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public class ValidationLocalisation
	{
		public ValidationType ErrorType;
		/// <summary>
		/// A dictionary of language code as key and message format as value
		/// </summary>
		public IDictionary<int, string> Localisation;
	}

	public static partial class CrmGeneratorExtensions
	{
		private class RelationProperty
		{
			internal PropertyInfo Property;
			internal RelationshipSchemaNameAttribute RelationAttribute;
		}

		private static IDictionary<string, IEnumerable<RelationProperty>> relationPropertyCache =
			new ConcurrentDictionary<string, IEnumerable<RelationProperty>>();

	    public static IEnumerable<TEntity> ProcessFetchXmlRelations<TEntity>(this IEnumerable<TEntity> entitiesParam, string fetchXml)
			where TEntity : GeneratedEntityBase
	    {
		    if (string.IsNullOrWhiteSpace(fetchXml))
		    {
				throw new ArgumentNullException(nameof(fetchXml));
		    }

		    if (entitiesParam == null)
		    {
				throw new ArgumentNullException(nameof(entitiesParam));
		    }

		    var entities = entitiesParam.ToArray();

		    if (!entities.Any())
		    {
			    return new TEntity[0];
		    }

		    foreach (var entity in entities)
			{
				var depth = 0;
				ProcessEntity(entity, entity, XElement.Parse(fetchXml).Element("entity"), ref depth);
			}

		    return entities.GroupBy(e => e.Id).Select(ConsolidateEntity).Where(e => e?.Id != Guid.Empty);
	    }

	    private static void ProcessEntity(Entity baseEntity, GeneratedEntityBase targetEntity, XElement xmlElement,
			ref int depth, string intersectingEntity = null)
	    {
		    foreach (var xLink in xmlElement.Elements("link-entity"))
		    {
			    depth++;

			    var linkedName = xLink.Attribute("name")?.Value;
			    var from = xLink.Attribute("from")?.Value;
			    var to = xLink.Attribute("to")?.Value;
			    var alias = GetLinkAlias(xLink, depth);

			    if (string.IsNullOrWhiteSpace(linkedName))
			    {
				    throw new ArgumentNullException(nameof(linkedName), "Linked entity name could not be found in FetchXML.");
			    }

			    if (string.IsNullOrWhiteSpace(from))
			    {
				    throw new ArgumentNullException(nameof(from), 
						$"'from' value could not be found in FetchXML for '{linkedName}'.");
			    }

			    if (string.IsNullOrWhiteSpace(to))
			    {
				    throw new ArgumentNullException(nameof(to), 
						$"'to' value could not be found in FetchXML for '{linkedName}'.");
			    }

			    if (string.IsNullOrWhiteSpace(alias))
			    {
				    throw new ArgumentNullException(nameof(alias), 
						$"'alias' value could not be found in FetchXML for '{linkedName}'.");
			    }

			    var relationParameters = targetEntity.RelationProperties
				    .Select(p => p.Value)
				    .Where(p => p.Length >= 5)
				    .FirstOrDefault(p => p[1].ToString() == linkedName && p[3].ToString() == from && p[4].ToString() == to);
			    var isNn = false;

			    if (relationParameters == null)
			    {
					// intersecting
				    relationParameters = targetEntity.RelationProperties
					    .Select(p => p.Value)
					    .Where(p => p.Length >= 9)
					    .FirstOrDefault(p => linkedName == p[2].ToString());
					isNn = true;

				    if (relationParameters == null)
				    {
					    relationParameters = targetEntity.RelationProperties
						    .Select(p => p.Value)
						    .Where(p => p.Length >= 3)
						    .FirstOrDefault(p => p[2].ToString() == intersectingEntity);
						isNn = false;

					    if (relationParameters == null)
					    {
						    continue;
					    }
				    }
			    }

			    var role = (relationParameters[8] as Type)?.IsArray == true ? EntityRole.Referenced : EntityRole.Referencing;
			    var schemaName = relationParameters[7].ToString();

			    var relationProperties = GetRelationInfoCache(targetEntity);

			    var relationProperty = relationProperties.FirstOrDefault(pa =>
				    pa.RelationAttribute.SchemaName == schemaName
					    && (pa.RelationAttribute.PrimaryEntityRole == role || pa.RelationAttribute.PrimaryEntityRole == null))?
				    .Property;
			    var propertyType = relationProperty?.PropertyType;

			    if (propertyType == null)
			    {
				    continue;
			    }

			    var relatedEntity = PrepareRelation(targetEntity, relationProperty);

			    if (relatedEntity == null)
			    {
				    continue;
			    }

			    foreach (var xAttribute in xLink.Elements("attribute"))
			    {
				    ProcessXAttribute(baseEntity, relatedEntity, alias, xAttribute);
			    }

			    if (xLink.Elements("all-attributes").Any())
			    {
				    ProcessAllAttributes(baseEntity, relatedEntity, alias);
			    }

				// go over the related entity as well for its own relations
			    ProcessEntity(baseEntity, isNn ? targetEntity : relatedEntity, xLink, ref depth, isNn ? linkedName : null);
		    }
	    }

		private static IEnumerable<RelationProperty> GetRelationInfoCache(GeneratedEntityBase targetEntity)
		{
			if (!relationPropertyCache.TryGetValue(targetEntity.LogicalName, out var relationProperties))
			{
				relationProperties = relationPropertyCache[targetEntity.LogicalName] =
					targetEntity.GetType().GetProperties()
						.Where(p => Attribute.IsDefined(p, typeof(RelationshipSchemaNameAttribute)))
						.Select(p =>
							new RelationProperty
							{
								Property = p,
								RelationAttribute = p.GetCustomAttribute<RelationshipSchemaNameAttribute>()
							});
			}

			return relationProperties;
		}

		private static string GetLinkAlias(XElement xLink, int depth)
	    {
		    var linkedName = xLink.Attribute("name")?.Value;

		    if (string.IsNullOrWhiteSpace(linkedName))
		    {
			    return null;
		    }

		    var alias = xLink.Attribute("alias")?.Value;

		    if (string.IsNullOrWhiteSpace(alias))
		    {
			    alias = $"{linkedName}{depth}";
		    }

		    return alias;
	    }

	    private static GeneratedEntityBase PrepareRelation(GeneratedEntityBase targetEntity, PropertyInfo relationProperty)
	    {
		    var propertyType = relationProperty?.PropertyType;

		    if (propertyType == null)
		    {
			    return null;
		    }

		    var isArray = typeof(IEnumerable).IsAssignableFrom(propertyType);
		    var relatedEntityType = propertyType;

		    if (isArray)
		    {
			    relatedEntityType = propertyType.GetElementType();
		    }

		    if (relatedEntityType == null)
		    {
			    return null;
		    }

		    var relatedEntity = Activator.CreateInstance(relatedEntityType) as GeneratedEntityBase;

		    if (relatedEntity == null)
		    {
			    return null;
		    }

		    object relatedValue = relatedEntity;
		    var currentValue = relationProperty.GetValue(targetEntity);

		    if (isArray)
		    {
			    var relatedList = (object[])(currentValue ?? Activator.CreateInstance(propertyType, 1));
			    relatedList[0] = relatedEntity;
			    relatedValue = relatedList;
		    }
		    else if (currentValue != null)
		    {
			    // already parsed N-1
			    return null;
		    }

		    relationProperty.SetValue(targetEntity, relatedValue);

		    return relatedEntity;
	    }

		private static void ProcessXAttribute(Entity baseEntity, GeneratedEntityBase relatedEntity, string relatedAlias,
			XElement xAttribute)
		{
			var	attributeName = xAttribute.Attribute("name")?.Value;
			var attributeAlias = xAttribute.Attribute("alias")?.Value;
			var isAliasedSame = string.IsNullOrWhiteSpace(relatedAlias) || attributeName == attributeAlias;

			if (!string.IsNullOrWhiteSpace(attributeAlias))
			{
				attributeName = attributeAlias;
			}

			ProcessAttribute(baseEntity, relatedEntity, relatedAlias, attributeName, isAliasedSame);
		}

		private static void ProcessAttribute(Entity baseEntity, GeneratedEntityBase relatedEntity, string relatedAlias,
			string attributeName, bool isAliasedSame)
	    {
		    var attribute = baseEntity.Attributes
			    .FirstOrDefault(a => !string.IsNullOrWhiteSpace(relatedAlias) && a.Key == $"{relatedAlias}.{attributeName}").Value
			    ?? baseEntity.Attributes
				    .FirstOrDefault(a => isAliasedSame && a.Key == attributeName).Value;

		    if (attribute is AliasedValue)
		    {
			    var aliasedValue = attribute as AliasedValue;
			    relatedEntity[aliasedValue.AttributeLogicalName] = aliasedValue.Value;
			    return;
		    }

		    if (attribute != null)
		    {
			    relatedEntity[attributeName] = attribute;
		    }
	    }

		private static void ProcessAllAttributes(Entity baseEntity, GeneratedEntityBase relatedEntity, string relatedAlias)
		{
			var attributes = baseEntity.Attributes
				.Where(a =>
					string.IsNullOrWhiteSpace(relatedAlias)
						? !a.Key.Contains($".")
						: a.Key.StartsWith($"{relatedAlias}."));

			foreach (var pair in attributes)
			{
				var attribute = pair.Value;

				AliasedValue aliasedValue;

				if (attribute is AliasedValue)
				{
					aliasedValue = attribute as AliasedValue;
					relatedEntity[aliasedValue.AttributeLogicalName] = aliasedValue.Value;
					continue;
				}

				if (attribute != null)
				{
					relatedEntity[pair.Key] = attribute;
				}
			}
	    }

	    private static TEntity ConsolidateEntity<TEntity>(IGrouping<Guid, TEntity> grouping)
		    where TEntity : GeneratedEntityBase
	    {
		    if (!grouping.Any())
		    {
			    return null;
		    }

		    var baseEntity = grouping.First();

		    var relationProperties = GetRelationInfoCache(baseEntity);
		    var baseRelationProperties = relationProperties
			    .Where(x => x.Property.PropertyType.IsArray
				    && (x.RelationAttribute.PrimaryEntityRole == EntityRole.Referenced
					    || x.RelationAttribute.PrimaryEntityRole == null)).ToArray();

		    foreach (var entity in grouping.Skip(1))
		    {
			    foreach (var relationProperty in baseRelationProperties)
			    {
				    var currentBaseRelationInfo = baseRelationProperties
					    .FirstOrDefault(x => x.RelationAttribute.SchemaName == relationProperty.RelationAttribute.SchemaName)?
						.Property;
				    var currentRelation = (GeneratedEntityBase[])relationProperty.Property.GetValue(entity);

				    if (currentBaseRelationInfo == null || currentRelation == null)
				    {
					    relationProperty.Property.SetValue(baseEntity, null);
					    continue;
				    }

				    var currentBaseRelation = ((GeneratedEntityBase[])currentBaseRelationInfo.GetValue(baseEntity))?
						.Where(e => e?.Id != Guid.Empty).ToArray();

					if (currentBaseRelation == null || !currentBaseRelation.Any())
					{
						currentBaseRelationInfo.SetValue(baseEntity, null);
						continue;
					}

					var baseLength = currentBaseRelation?.Length ?? 0;

				    var newBaseRelation = (GeneratedEntityBase[])Activator.CreateInstance(currentRelation.GetType(), baseLength + 1);

				    if (currentBaseRelation?.Length > 0)
				    {
					    Array.Copy(currentBaseRelation, newBaseRelation, baseLength);
				    }

				    Array.Copy(currentRelation.Where(e => e?.Id != Guid.Empty).ToArray(), 0, newBaseRelation, baseLength, 1);
				    currentBaseRelationInfo.SetValue(baseEntity, newBaseRelation);
			    }
		    }

		    foreach (var baseRelationPropertyInfo in baseRelationProperties)
		    {
			    var baseRelationProperty = baseRelationPropertyInfo.Property;

				var currentRelation = (GeneratedEntityBase[])baseRelationProperty.GetValue(baseEntity);
				var currentRelationFiltered = currentRelation?.Where(e => e?.Id != Guid.Empty).ToArray();

				if (currentRelationFiltered == null || !currentRelationFiltered.Any())
			    {
					baseRelationProperty.SetValue(baseEntity, null);
				    continue;
			    }

			    var related = currentRelation.GroupBy(e => e.Id).Select(ConsolidateEntity)
					.Where(e => e?.Id != Guid.Empty).ToArray();

				if (related == null || !related.Any())
				{
					baseRelationProperty.SetValue(baseEntity, null);
					continue;
				}

				var newRelation = (GeneratedEntityBase[])Activator.CreateInstance(currentRelation.GetType(), related.Length);
			    Array.Copy(related, newRelation, related.Length);
				baseRelationProperty.SetValue(baseEntity, newRelation);
		    }

		    return baseEntity;
	    }
		
		/// <summary>
		/// Converts an enum constant to an OptionSetValue object..
		/// </summary>
		/// <param name="enumMember">The early-bound enum member constant; e.g.: 'Account.IndustryCode.Accounting'</param>
		/// <returns>The OptionSetValue object.</returns>
		public static OptionSetValue ToOptionSetValue(this Enum enumMember)
		{
			return new OptionSetValue(int.Parse(enumMember.ToString("d")));
		}

		/// <summary>
		///     Calling this method on a LINQ will result in limiting attributes retrieved from CRM on any early-bound entity in
		///     the query.<br />
		///     The properties defined in the entity's class will be the ones retrieved from CRM by default; all other attributes
		///     in CRM will be ignored.<br />
		///     The entity <b>must</b> be passed to a constructor of the same type.<br />
		///     Example:
		///     <code>
		/// (from account in new XrmServiceContext(service).AccountSet
		/// select new Account(account)).ToList()
		/// </code>
		/// </summary>
		public static IQueryable<TEntity> LimitAttributes<TEntity>(this IQueryable<TEntity> q) where TEntity : Entity
		{
			return q.InterceptWith(new LinqEntityLimiter());
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationTypes">An array of validations to run. Default is all.</param>
		/// <returns>A single message containing all validation errors.</returns>
		public static string GetValidationErrorsMessage(this Entity entityRecord, ValidationType[] validationTypes)
		{
			return GetValidationErrorsMessage(entityRecord,
				validationLocationsDefaults.Where(local => validationTypes.Contains(local.ErrorType)).ToArray());
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationLocalisation">
		///     [OPTIONAL] An array containing validation types with the message format to use for the validation error.<br />
		///     For validation type "Range", the message format takes three params for min, max, and actual value respectively;
		///         e.g.: "Value must be between {0} and {1}. Actual value was {2}.".<br />
		///     For validation type "MaxLength", the message format takes two params;
		///		    e.g.: "Value length must be less than {0}. Actual value was {1}."<br />
		///     Only include ONE localisation language.<br />
		///     Default is a check on all validation types.
		/// </param>
		/// <returns>A single message containing all validation errors.</returns>
		public static string GetValidationErrorsMessage(this Entity entityRecord, ValidationLocalisation[] validationLocalisation = null)
		{
			if (validationLocalisation != null
				&& validationLocalisation.Any(local => local.Localisation.Count > 1))
			{
				throw new ArgumentOutOfRangeException("validationLocalisation",
					"There should only be one validation localisation language for this method.");
			}

			var validationErrorMessages = GetValidationErrorMessages(entityRecord, validationLocalisation);

			if (validationErrorMessages.Any())
			{
				return validationErrorMessages.Aggregate(
					(message1, message2) => message1 + "\r\n-----------------------\r\n" + message2);
			}

			return null;
		}

		private static readonly ValidationLocalisation[] validationLocationsDefaults =
		{
			new ValidationLocalisation
			{
				ErrorType = ValidationType.Required,
				Localisation = new Dictionary<int, string>
				               {
					               {1033, "Value cannot be null."}
				               }
			},
			new ValidationLocalisation
			{
				ErrorType = ValidationType.Range,
				Localisation = new Dictionary<int, string>
				               {
					               {1033, @"Attribute value must be between ""{0}"" and ""{1}"", inclusive. Actual value was ""{2}""."}
				               }
			},
			new ValidationLocalisation
			{
				ErrorType = ValidationType.MaxLength,
				Localisation = new Dictionary<int, string>
				               {
					               {1033, @"Attribute length must be less than ""{0}"". Actual attribute value was ""{1}""."}
				               }
			}
		};

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationTypes">An array of validations to run.</param>
		/// <returns>A list of messages indicating validation errors.</returns>
		public static List<string> GetValidationErrorMessages(this Entity entityRecord, ValidationType[] validationTypes)
		{
			return GetValidationErrorMessages(entityRecord,
				validationLocationsDefaults.Where(local => validationTypes.Contains(local.ErrorType)).ToArray());
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationLocalisation">
		///     [OPTIONAL] An array containing validation types with the message format to use for the validation error.<br />
		///     For validation type "Range", the message format takes three params for min, max, and actual value respectively;
		///         e.g.: "Value must be between {0} and {1}. Actual value was {2}.".<br />
		///     For validation type "MaxLength", the message format takes two params;
		///		    e.g.: "Value length must be less than {0}. Actual value was {1}."<br />
		///     Only include ONE localisation language.<br />
		///     Default is a check on all validation types.
		/// </param>
		/// <returns>A list of messages indicating validation errors.</returns>
		public static List<string> GetValidationErrorMessages(this Entity entityRecord, ValidationLocalisation[] validationLocalisation = null)
		{
			if (validationLocalisation != null
			    && validationLocalisation.Any(local => local.Localisation.Count > 1))
			{
				throw new ArgumentOutOfRangeException("validationLocalisation",
					"There should only be one validation localisation language for this method.");
			}

			var validationErrors = GetValidationErrors(entityRecord, validationLocalisation);

			if (validationErrors.Any())
			{
				var messages = validationErrors.Select(error => error.ErrorMessage.Values.First()).ToList();
				var id = ((dynamic)entityRecord).Id;
				messages.Insert(0, string.Format("Record of type \"{0}\"" + (id != null ? " and ID \"{1}\"" : "")
													+ " has invalid values.", entityRecord.GetType().Name, id));
				return messages;
			}

			return null;
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationTypes">An array of validations to run.</param>
		/// <returns>A list of validation errors in the form of <see cref="ValidationError"/>.</returns>
		public static List<ValidationError> GetValidationErrors(this Entity entityRecord, ValidationType[] validationTypes)
		{
			return GetValidationErrors(entityRecord,
				validationLocationsDefaults.Where(local => validationTypes.Contains(local.ErrorType)).ToArray());
		}

		///  <summary>
		///      Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///      Validation checks: required, numeric value range, and string length.<br />
		///  </summary>
		///  <param name="validationLocalisation">
		///      [OPTIONAL] An array containing validation types with the message format to use for the validation error.<br />
		///      For validation type "Range", the message format takes three params for min, max, and actual value respectively;
		///          e.g.: "Value must be between {0} and {1}. Actual value was {2}.".<br />
		///      For validation type "MaxLength", the message format takes two params;
		/// 		    e.g.: "Value length must be less than {0}. Actual value was {1}."<br />
		///      Default is a check on all validation types.
		///  </param>
		/// <returns>A list of validation errors in the form of <see cref="ValidationError"/>.</returns>
		public static List<ValidationError> GetValidationErrors(this Entity entityRecord, ValidationLocalisation[] validationLocalisation = null)
		{
			var id = ((dynamic) entityRecord).Id;
			var fields = entityRecord.GetType().GetProperties();
			var exceptions = new List<ValidationError>();

			validationLocalisation = validationLocalisation ?? validationLocationsDefaults;

			var localisation = validationLocalisation.FirstOrDefault(local => local.ErrorType == ValidationType.Required);

			if (localisation != null)
			{
				exceptions.AddRange(from fieldQ in fields
				                    where Attribute.IsDefined(fieldQ, typeof (RequiredAttribute))
				                          && fieldQ.GetValue(entityRecord) == null
				                    select new ValidationError
				                           {
					                           RecordId = id,
					                           AttributeName = fieldQ.Name,
					                           ErrorMessage =
						                           localisation.Localisation.ToDictionary(local => local.Key, local => local.Value),
					                           ErrorType = ValidationType.Required
				                           });
			}

			localisation = validationLocalisation.FirstOrDefault(local => local.ErrorType == ValidationType.Range);

			if (localisation != null)
			{
				foreach (var field in fields.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof (RangeAttribute)) && fieldQ.GetValue(entityRecord) != null))
				{
					var fieldValue = field.GetValue(entityRecord);
					Type type = field.GetCustomAttribute<RangeAttribute>().OperandType;

					var method = type.GetMethods().FirstOrDefault(methodQ => methodQ.GetParameters().Length == 1 && methodQ.Name == "Parse");

					var min = (IComparable) method.Invoke(null, new object[] {field.GetCustomAttribute<RangeAttribute>().Minimum});
					var max = (IComparable) method.Invoke(null, new object[] {field.GetCustomAttribute<RangeAttribute>().Maximum});

					if (fieldValue != null && (min.CompareTo(fieldValue) == 1 || max.CompareTo(fieldValue) == -1))
					{
						exceptions.Add(new ValidationError
						               {
							               RecordId = id,
							               AttributeName = field.Name,
							               ErrorMessage = localisation.Localisation.ToDictionary(local => local.Key,
									               local => string.Format(local.Value, min, max, fieldValue)),
							               ErrorType = ValidationType.Range,
							               NumericValue = decimal.Parse(fieldValue.ToString()),
							               NumericRangeMin = decimal.Parse(min.ToString()),
							               NumericRangeMax = decimal.Parse(max.ToString())
						               });
					}
				}
			}


			localisation = validationLocalisation.FirstOrDefault(local => local.ErrorType == ValidationType.MaxLength);

			if (localisation != null)
			{
				exceptions.AddRange(from fieldQ in fields.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof (MaxLengthAttribute)))
				                    let fieldValue = fieldQ.GetValue(entityRecord) as string
				                    let maxLength = fieldQ.GetCustomAttribute<MaxLengthAttribute>().Length
				                    where fieldValue != null && fieldValue.Length > maxLength
				                    select new ValidationError
				                           {
					                           RecordId = id,
					                           AttributeName = fieldQ.Name,
					                           ErrorMessage = localisation.Localisation.ToDictionary(local => local.Key,
							                           local => string.Format(local.Value, maxLength, fieldValue)),
					                           ErrorType = ValidationType.MaxLength,
					                           StringValue = fieldValue,
					                           StringMaxLength = maxLength
				                           });
			}

			return exceptions;
		}

		public static TEntity ConvertTo<TEntity>(this GeneratedEntityBase crmRecord) where TEntity : EntityContract
		{
			// create entity object
			var record = Activator.CreateInstance<TEntity>();

			var entityType = typeof(TEntity);
			var entityLogicalName = entityType.GetCustomAttribute<CrmEntityMappingAttribute>().LogicalName;
			var properties = entityType.GetProperties().ToArray();

			// if logical names don't match
			if (entityLogicalName != crmRecord.LogicalName)
			{
				throw new Exception(string.Format("CRM entity '{0}' doesn't map to entity '{1}'.",
					crmRecord.GetType().Name, entityType.Name));
			}

			// go over all fields in the contract entity that has the mapping attribute
			foreach (var field in properties
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))
								 && !Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = field.GetCustomAttribute<CrmFieldMappingAttribute>();
				SetValueInRecord(record, field, crmRecord, mapping);
			}

			var relations = properties
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))
					&& !Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))).ToArray();

			// go over all relations in the contract entity that has the mapping attribute
			foreach (var relation in relations)
			{
				// get the value of the mapping attribute
				var mapping = relation.GetCustomAttribute<CrmRelationMappingAttribute>();
				SetRelationInRecord(record, relation, crmRecord, mapping);
			}

			var flattableRelations = relations
				.Select(r =>
					new
					{
						r,
						p = properties
							.Where(p => Attribute.IsDefined(p, typeof(CrmFieldMappingAttribute))
								   && Attribute.IsDefined(p, typeof(CrmRelationMappingAttribute)))
							.Where(
								p =>
								{
									var rAttr = r.GetCustomAttribute<CrmRelationMappingAttribute>();
									var pAttr = p.GetCustomAttribute<CrmRelationMappingAttribute>();
									return rAttr.SchemaName == pAttr.SchemaName
										&& rAttr.Role == pAttr.Role;
								})
					})
				.Where(r => r.p.Any());

			// go over flattened relations in the contract entity that has the mapping attribute
			foreach (var r in flattableRelations)
			{
				SetRelationInRecord(record, r.r, r.p);
			}

			return record;
		}

		private static void SetValueInRecord<TEntity>(TEntity entity, PropertyInfo field, GeneratedEntityBase crmRecord,
			CrmFieldMappingAttribute mapping)
			where TEntity : EntityContract
		{
			// if key not found, then the CRM record doesn't have that value set
			var crmValue = crmRecord.GetAttributeValue<object>(mapping.LogicalName);

			if (crmValue == null)
			{
				return;
			}

			var crmField = crmRecord.GetType().GetProperties()
				.FirstOrDefault(propQ => Attribute.IsDefined(propQ, typeof(AttributeLogicalNameAttribute))
					&& propQ.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName == mapping.LogicalName);

			if (crmField == null)
			{
				return;
			}

			var value = crmField.GetValue(crmRecord);

			if (value == null)
			{
				return;
			}

			// convert types
			if (value is Enum)
			{
				var underlyingType = Nullable.GetUnderlyingType(field.PropertyType);

				if (underlyingType == null)
				{
					return;
				}

				// can't set enum value with int using reflection!
				field.SetValue(entity, Enum.ToObject(underlyingType, Convert.ToInt32(value)));

				var labelsProperty = typeof(TEntity).GetProperties().FirstOrDefault(propQ => propQ.Name == field.Name + "Labels");

                if (labelsProperty != null)
                {
                    // get the label value from the CRM record
                    var matchingProperty = crmRecord.GetType().GetProperties().FirstOrDefault(propQ => propQ.Name == field.Name + "Labels");

                    // if it has a value, set it in contract
                    if (matchingProperty != null)
                    {
                        labelsProperty.SetValue(entity, matchingProperty.GetValue(crmRecord));
                    }
                }
			}
			else if (crmValue is EntityReference)
			{
				var entityRef = (EntityReference) crmValue;

				if (field.PropertyType == typeof(Guid?))
				{
					field.SetValue(entity, entityRef.Id);
				}
				else if (field.PropertyType == typeof(LookupValue))
				{
					field.SetValue(entity, new LookupValue(entityRef.LogicalName, entityRef.Id));
				}

				var nameField = typeof(TEntity).GetProperties().FirstOrDefault(fieldQ => fieldQ.Name == field.Name + "Name");

				if (nameField != null && entityRef.Name != null)
				{
					nameField.SetValue(entity, entityRef.Name);
				}

				var labelsProperty = typeof(TEntity).GetProperties().FirstOrDefault(propQ => propQ.Name == field.Name + "Labels");

                if (labelsProperty != null)
                {
                    // get the label value from the CRM record
                    var matchingProperty = crmRecord.GetType().GetProperties().FirstOrDefault(propQ => Attribute.IsDefined(propQ, typeof(LabelAttribute))
                        && propQ.GetCustomAttribute<LabelAttribute>().FieldLogicalName == labelsProperty.GetCustomAttribute<LabelAttribute>().FieldLogicalName);

                    // if it has a value, set it in contract
                    if (matchingProperty != null)
                    {
                        labelsProperty.SetValue(entity, matchingProperty.GetValue(crmRecord));
                    }
                }
			}
			else
			{
				field.SetValue(entity, value);
			}
		}

		private static void SetRelationInRecord<TEntity>(TEntity record, PropertyInfo field, Entity crmRecord,
			CrmRelationMappingAttribute mapping)
			where TEntity : EntityContract
		{
			var crmRelation = crmRecord.GetType().GetProperties()
				.FirstOrDefault(propQ => Attribute.IsDefined(propQ, typeof(RelationshipSchemaNameAttribute))
					&& propQ.GetCustomAttribute<RelationshipSchemaNameAttribute>().SchemaName == mapping.SchemaName
					&& propQ.GetCustomAttribute<RelationshipSchemaNameAttribute>().PrimaryEntityRole.ToString() == mapping.Role.ToString());

			if (crmRelation == null)
			{
				return;
			}

			var fieldType = field.PropertyType;

			object convertedValue = null;

			// x-N relation
			if (typeof(Array).IsAssignableFrom(fieldType))
			{
				var value = crmRelation.GetValue(crmRecord) as Array;

				if (value == null || value.Length <= 0)
				{
					return;
				}

				// get the contract type for the relation
				var elementType = fieldType.GetElementType();

				if (elementType == null)
				{
					return;
				}

				// create an array for the related entities of the appropriate type
				var relatedRecords = Array.CreateInstance(elementType, value.Length);

				// create the method reference that will be used to convert the related entities to the CRM entities
				var method = MethodBase.GetCurrentMethod().DeclaringType?
					.GetMethod("ConvertTo")?.MakeGenericMethod(elementType);

				if (method == null)
				{
					return;
				}

				// convert all entities to contract entities
				var objectRelatedRecords =
					(from object relatedRecord in value
					 select method.Invoke(relatedRecord, new[] { relatedRecord })).ToArray();

				// copy the object entities to the array of the specific type
				Array.Copy(objectRelatedRecords, relatedRecords, relatedRecords.Length);
				convertedValue = relatedRecords;
			}
			else if (typeof(EntityContract).IsAssignableFrom(fieldType))
			{
				var value = crmRelation.GetValue(crmRecord) as GeneratedEntityBase;

				if (value == null)
				{
					return;
				}

				// create the method reference that will be used to convert the related entities to the CRM entities
				var method = MethodBase.GetCurrentMethod().DeclaringType?
					.GetMethod("ConvertTo")?.MakeGenericMethod(fieldType);

				if (method == null)
				{
					return;
				}

				convertedValue = method.Invoke(value, new object[] { value });
			}

			// set the related entities value in the entity
			field.SetValue(record, convertedValue);
		}

		private static void SetRelationInRecord(object record, PropertyInfo relationInfo, IEnumerable<PropertyInfo> flatPropertiesP)
		{
			var relation = relationInfo.GetValue(record);

			if (relation == null)
			{
				return;
			}

			var flatProperties = flatPropertiesP.ToArray();

			var relationProperties = relationInfo.PropertyType.GetProperties()
				.Where(p => Attribute.IsDefined(p, typeof(CrmFieldMappingAttribute))
					&& !Attribute.IsDefined(p, typeof(CrmRelationMappingAttribute)));

			foreach (var relationProperty in relationProperties)
			{
				var flatProperty = flatProperties
					.FirstOrDefault(f => f.GetCustomAttribute<CrmFieldMappingAttribute>().LogicalName
						== relationProperty.GetCustomAttribute<CrmFieldMappingAttribute>().LogicalName);

				if (flatProperty == null)
				{
					continue;
				}

				flatProperty.SetValue(record, relationProperty.GetValue(relation));
			}

			relationInfo.SetValue(record, null);
		}

		/// <summary>
		/// Returns an array of logical names whose property is marked for WCF contract.
		/// </summary>
		/// <param name="entity"></param>
		/// <returns>An array of logical names.</returns>
		public static string[] GetDataMemberAttributes(this Entity entity)
		{
			return entity.GetType().GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(DataMemberAttribute)) && Attribute.IsDefined(fieldQ, typeof(AttributeLogicalNameAttribute)))
				.Select(field => field.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName).ToArray();
		}

		/// <summary>
		/// Returns an array of logical names of the properties.
		/// </summary>
		/// <param name="entity"></param>
		/// <returns>An array of logical names.</returns>
		public static string[] GetAttributeNames(this Entity entity)
		{
			return entity.GetType().GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(AttributeLogicalNameAttribute)) && !Attribute.IsDefined(fieldQ, typeof(RelationshipSchemaNameAttribute)))
				.Select(field => field.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName).ToArray();
		}

		/// <summary>
		/// Loads the values of data member properties from CRM.
		/// </summary>
		/// <param name="entity"></param>
		/// <param name="service">CRM organisation service.</param>
		public static void LoadDataMemberAttributes(this Entity entity, IOrganizationService service)
		{
			LoadAttributeValues(entity, service, entity.GetDataMemberAttributes());
		}

		/// <summary>
		/// Loads the values of all properties from CRM.
		/// </summary>
		/// <param name="entity"></param>
		/// <param name="service">CRM organisation service.</param>
		/// <param name="attributes"></param>
		public static void LoadAttributeValues(this Entity entity, IOrganizationService service, params string[] attributes)
		{
			try
			{
				entity.Id = entity.Id;
			}
			catch
			{
				throw new Exception("Entity is ready only. Set 'MergeOption' to 'NoTracking' in the context used for fetching this entity.");
			}

			var isLoadAll = attributes == null || attributes.Length <= 0;

			if (isLoadAll)
			{
				entity.Attributes.Clear();
			}

			foreach (var attribute in service.Retrieve(entity.LogicalName, entity.Id, new ColumnSet(isLoadAll ? entity.GetAttributeNames() : attributes)).Attributes)
			{
				entity[attribute.Key] = attribute.Value;
			}
		}
	}

	#endregion

	#region Helpers

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class GeneratedEntityBase : Entity	{
		protected GeneratedEntityBase()
		{}

		protected GeneratedEntityBase(string logicalName) : base(logicalName)
		{}

		/// <summary>
		///     Initialises this entity with the given keys and values.
		/// </summary>
		protected GeneratedEntityBase(string[] keys, object[] values, string logicalName) : this(logicalName)
		{
			for (var i = 0; i < keys.Length; i++)
			{
				var key = keys[i];
				var value = values[i];

				if (value == null)
				{
					continue;
				}

				Attributes[key] = value;
			}
		}

		/// <summary>
		/// Constructor for populating via LINQ queries given a LINQ anonymous type.<br />
		/// <b>OR</b> ...<br />
		///     Constructor that Limits attributes retrieved from CRM on any early-bound entity in a LINQ query.<br />
		///     The properties and fields defined in this class will be the ones retrieved from CRM by default; all other attributes
		///     in CRM will be ignored.<br />
		///     The selected early-bound record of this class's type in the query <b>must</b> be passed to this constructor.<br />
		///     Example:
		///     <code>
		/// (from account in new XrmServiceContext(service).AccountSet
		/// select new Account(account)).ToList()
		/// </code>
		/// </summary>
		protected GeneratedEntityBase(object obj, string logicalName) : base(logicalName)
		{ }

		/// <summary>
		///     Limits attributes retrieved from CRM on any early-bound entity in a LINQ.<br />
		///     The properties and fields defined in the 'limitingType' class will be the ones retrieved from CRM by default;
		///     all other attributes in CRM will be ignored.<br />
		///     The selected early-bound record of this class's type in the query <b>must</b> be passed to this constructor.<br />
		///     Example:
		///     <code>
		/// (from account in new XrmServiceContext(service).AccountSet
		/// select new Account(account, typeof(AccountModel))).ToList()
		/// </code>
		/// </summary>
		protected GeneratedEntityBase(object obj, Type limitingType, string logicalName) : base(logicalName)
		{ }

		[DataMember]
		private List<string> NullValuedAttributes { get; set; }
		protected Microsoft.Xrm.Sdk.AttributeCollection backupAttributeCollection;
		protected FormattedValueCollection backupFormattedCollection;
		protected RelatedEntityCollection backupRelatedEntityCollection;
		internal IList<QueryAction> DeferredQueriesList = new List<QueryAction>();
		protected IDictionary<string, object[]> relationProperties;
		public virtual IDictionary<string, object[]> RelationProperties { get { return new Dictionary<string, object[]>(); } }

		#region Serialisation events

		[OnSerializing]
		private void SerializingInitializer(StreamingContext ctx)
		{
			backupAttributeCollection = new Microsoft.Xrm.Sdk.AttributeCollection();
			backupAttributeCollection.AddRange(Attributes);
			Attributes.Clear();

			backupFormattedCollection = new FormattedValueCollection();
			backupFormattedCollection.AddRange(FormattedValues);
			FormattedValues.Clear();

			backupRelatedEntityCollection = new RelatedEntityCollection();
			backupRelatedEntityCollection.AddRange(RelatedEntities);
			RelatedEntities.Clear();
		}

		[OnSerialized]
		private void SerializedInitializer(StreamingContext ctx)
		{
			Attributes.Clear();
			Attributes.AddRange(backupAttributeCollection);
			backupAttributeCollection = null;

			FormattedValues.Clear();
			FormattedValues.AddRange(backupFormattedCollection);
			backupFormattedCollection = null;

			RelatedEntities.Clear();
			RelatedEntities.AddRange(backupRelatedEntityCollection);
			backupRelatedEntityCollection = null;
		}

		[OnDeserialized]
		private void DeserializedInitializer(StreamingContext ctx)
		{
			LogicalName = (string)GetType().GetField("EntityLogicalName").GetRawConstantValue();
			Attributes.Where(attribute => attribute.Value == null).ToList().ForEach(attribute => Attributes.Remove(attribute.Key));
			if (NullValuedAttributes != null && NullValuedAttributes.Count > 0)
			{
				NullValuedAttributes.ForEach(attribute =>
				{
					var property = GetType().GetProperty(attribute);
					if (property == null)
					{
						throw new Exception("Couldn't find the property '" + attribute + "' in entity.");
					}
					property.SetValue(this, null);
				});
			}
		}

		#endregion

		public XrmServiceContext ServiceContext { get; set; }

		public void LoadLookupLabels(IOrganizationService service, bool isDeferred = false)
		{
			var properties = from propQ in this.GetType().GetProperties()
			                 let propIdQ = this.GetType().GetProperty(propQ.Name.Replace("Labels", ""))
			                 where Attribute.IsDefined(propQ, typeof(LabelAttribute))
			                       && (Guid?) propIdQ.GetValue(this) != null
			                 select new
			                        {
				                        property = propQ,
				                        id = propIdQ.GetValue(this),
				                        attribute = propQ.GetCustomAttribute<LabelAttribute>()
			                        };

			foreach (var property in properties)
			{
				var fields = property.attribute.LabelFieldNames.Split(',');

				var query = new QueryExpression(property.attribute.LogicalName);
				query.Criteria.AddCondition(property.attribute.IdFieldName, ConditionOperator.Equal, property.id);
				query.ColumnSet = new ColumnSet(fields.Select(field => field.Substring(5)).ToArray());

				var queryAction =
					new QueryAction(query)
					{
						Action =
							result =>
							{
								var response = result as RetrieveMultipleResponse;
								if (response == null) return;

								var entityQ = response.EntityCollection.Entities.FirstOrDefault();
								if (entityQ == null) return;

								var englishLabel = (string) entityQ.Attributes.FirstOrDefault(
									attribute => ("1033_" + attribute.Key) == fields.FirstOrDefault(field => field.Contains("1033_"))).Value;
								var dictionary = new Dictionary<int, string>();
								dictionary[1033] = englishLabel;
								property.property.SetValue(this, dictionary);
							}
					};

				if (isDeferred)
				{
					this.DeferredQueriesList.Add(queryAction);
				}
				else
				{
					queryAction.Action.Invoke(service.Execute(new RetrieveMultipleRequest{Query = query}));
				}
			}
		}

		#region Relationship methods

		protected override IEnumerable<TEntity> GetRelatedEntities<TEntity>(string relationshipSchemaName, EntityRole? primaryEntityRole)
		{
		    var key = new Relationship(relationshipSchemaName) { PrimaryEntityRole = primaryEntityRole };

			var enumerable = base.GetRelatedEntities<TEntity>(relationshipSchemaName, primaryEntityRole);

			if (ServiceContext != null && enumerable == null)
			{
				if (!ServiceContext.IsAttached(this))
				{
					throw new Exception("The context that loaded this entity must be used to load relationships, " +
										"or set 'MergeOption' to anything other than 'NoTracking' in the context before fetching this entity using LINQ.");
				}

				ServiceContext.LoadProperty(this, key);
			}

			enumerable = base.GetRelatedEntities<TEntity>(relationshipSchemaName, primaryEntityRole);
			
			if (enumerable == null)
			{
				if (backupRelatedEntityCollection != null && backupRelatedEntityCollection.Contains(key))
					enumerable = backupRelatedEntityCollection[key].Entities.Cast<TEntity>();
			}

			return enumerable;
		}

		protected override TEntity GetRelatedEntity<TEntity>(string relationshipSchemaName, EntityRole? primaryEntityRole)
		{
			var key = new Relationship(relationshipSchemaName) { PrimaryEntityRole = primaryEntityRole };

			var result = base.GetRelatedEntity<TEntity>(relationshipSchemaName, primaryEntityRole);

			if (ServiceContext != null && result == null)
			{
				if (!ServiceContext.IsAttached(this))
				{
					throw new Exception("The context that loaded this entity must be used to load relationships, " +
										"or set 'MergeOption' to anything other than 'NoTracking' in the context before fetching this entity using LINQ.");
				}

				ServiceContext.LoadProperty(this, key);
			}

			result = base.GetRelatedEntity<TEntity>(relationshipSchemaName, primaryEntityRole);

			if (result == null)
			{
				if (backupRelatedEntityCollection != null && backupRelatedEntityCollection.Contains(key))
					result = (TEntity)backupRelatedEntityCollection[key].Entities.FirstOrDefault();
			}
			
			return result;
		}

		#endregion
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class GeneratedEntity<TRelationName> : GeneratedEntityBase where TRelationName : RelationNameBase
	{
		protected GeneratedEntity(string logicalName) : base(logicalName)
		{ }

		/// <inheritdoc/>
		protected GeneratedEntity(string[] keys, object[] values, string logicalName) : base(keys, values, logicalName)
		{ }

		/// <inheritdoc/>
		protected GeneratedEntity(object obj, Type limitingType, string logicalName) : base(obj, limitingType, logicalName)
		{ }

		/// <inheritdoc/>
		protected GeneratedEntity(object obj, string logicalName) : base(obj, logicalName)
		{ }

		#region Relationship methods

		/// <summary>
		/// Fetch the records related to this entity on this relationship. 
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, params string[] attributes)
		{
			return LoadRelation(relationName, service, false, -1, -1, null, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. 
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, -1, -1, null, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, FilterExpression filter, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, -1, -1, null, filter, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, recordCountLimit, -1, null, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, int page, string cookie, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, recordCountLimit, page, cookie, null, attributes);
		}

		/// <summary>
		/// Fetch the next page of records related to this entity on this relationship using the previous paging info object returned.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, RelationPagingInfo pagingInfo, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, pagingInfo.RecordCountLimit, pagingInfo.NextPage, pagingInfo.Cookie, pagingInfo.Filter, pagingInfo, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, int page, string cookie, FilterExpression filter, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, recordCountLimit, page, cookie, filter, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, int page, string cookie, FilterExpression filter, RelationPagingInfo pagingInfo, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			if (!RelationProperties.ContainsKey(relationName.Name)) {
				throw new Exception("Relation does not exist in entity, or is not generated.");
			}
			var relationPagingInfo = pagingInfo ?? new RelationPagingInfo
				{
					RecordCountLimit = recordCountLimit,
					Filter = filter,
					Cookie = cookie,
					NextPage = page
				};
			var relationParams = RelationProperties[relationName.Name];
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, (string) relationParams[1], (string) relationParams[2], (string) relationParams[3], (string) relationParams[4], (string) relationParams[5], (string) relationParams[6],
					recordCountLimit, page, cookie, filter, attributes));
			var queryAction = queryActionObject.Action =
							  resultQ => {
								  var response = resultQ as RetrieveMultipleResponse;
								  var entityType = ((Type) relationParams[8]).GetElementType() ?? (Type) relationParams[8];
					              var resultArray = response == null ? ((List<Entity>) resultQ).Select(entityQ => entityQ.GetType().GetMethod("ToEntity").MakeGenericMethod(entityType).Invoke(entityQ, null)).ToArray()
	    				              : response.EntityCollection.Entities.Select(entityQ => entityQ.GetType().GetMethod("ToEntity").MakeGenericMethod(entityType).Invoke(entityQ, null)).ToArray();
					              var relatedRecords = Array.CreateInstance(entityType, resultArray.Length);
					              Array.Copy(resultArray, relatedRecords, resultArray.Length);
								  DeferredQueriesList.Remove(queryActionObject);
								  var newValue = relatedRecords.Length <= 0 ? null : (((Type) relationParams[8]).GetElementType() == null ? relatedRecords.GetValue(0) : relatedRecords);
								  GetType().GetProperty((string) relationParams[0]).SetValue(this, newValue);
							  };
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page, cookie, relationPagingInfo));
			return relationPagingInfo;
		}

		#endregion
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public class RelationPagingInfo
	{
		public string Cookie;
		public int NextPage = 1;
		public int RecordCountLimit = -1;
		public FilterExpression Filter;
		public bool IsMoreRecords = true;
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class RelationNameBase
	{
		public string Name;

		public RelationNameBase(string name)
		{
			Name = name;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal class QueryAction
	{
		public QueryExpression Query { get; set; }
		public Action<object> Action { get; set; }

		public QueryAction(QueryExpression query, Action<object> action = null)
		{
			Query = query;
			Action = action;
		}
	}

	public enum ValidationType
	{
		Required,
		Range,
		MaxLength
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class LookupKeysBase
	{
		public string Name;

		protected LookupKeysBase(string name)
		{
			Name = name;
		}
	}

	public interface ILookupKeys<in TKey> where TKey : LookupKeysBase
	{
		void AddKey(TKey key, object value);
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract]
	public class CrmActionBase<TInputs, TOutputs>
		where TInputs : CrmActionBase<TInputs, TOutputs>.InputsBase, new()
		where TOutputs : CrmActionBase<TInputs, TOutputs>.OutputsBase, new()
	{
		public IOrganizationService Service;
		public OrganizationRequest Request;
		public OrganizationResponse Response;
		public TInputs InputParams;
		public TOutputs OutputFields;
		
		public CrmActionBase(string actionName)
		{
			Request = new OrganizationRequest(actionName);
			InputParams = new TInputs() { Request = Request };
		}
		
		public CrmActionBase(IOrganizationService service, string actionName) : this(actionName)
		{
			Service = service;
		}

		public TOutputs Execute(IOrganizationService service = null)
		{
			if (service != null)
			{
				Service = service;
			}

			Response = Service.Execute(Request);

			return OutputFields = new TOutputs() { Response = Response };
		}
				
		public abstract class InputsBase
		{
			public OrganizationRequest Request;

			public InputsBase()
			{ }

			public InputsBase(OrganizationRequest request)
			{
				Request = request;
			}
		}
		
		public abstract class OutputsBase
		{
			public OrganizationResponse Response;

			public OutputsBase()
			{ }

			public OutputsBase(OrganizationResponse response)
			{
				Response = response;
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public static partial class GeneratorHelpers
	{
		#region Enums

		/// <summary>
		/// Get the value that corresponds to the label from the option-set,
		/// using the type of the class enclosing both, label type, and the language code given.
		/// </summary>
		/// <param name="labelType">The type of the class containing the labels; e.g.: 'typeof(Account.Enums.Labels.IndustryCode)'</param>
		/// <param name="label">The label to search for, corresponding to the value</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns>The value corresponding to the label</returns>
		public static int GetValue(Type labelType, string label, int languageCode = 1033)
		{
			var labelsType = labelType.DeclaringType;

			if (labelsType == null)
			{
				return -1;
			}

			var enumsType = labelsType.DeclaringType;

			if (enumsType == null)
			{
				return -1;
			}

			// get the fields with the same label from the label class
			var fields = labelType.GetFields()
				.Where(fieldQ => fieldQ.Name.Contains(languageCode.ToString())
					&& (string)fieldQ.GetValue(labelType) == label);

			if (!fields.Any())
			{
				return -1;
			}

			var field = fields.First();

			var entityType = enumsType.DeclaringType;

			if (entityType == null)
			{
				return -1;
			}

			var enumType = entityType.GetNestedType(labelType.Name + "Enum");

			if (enumType == null)
			{
				return -1;
			}

			// get the enum constant corresponding to the field name
			var enumConstant = Enum.Parse(enumType, field.Name.Replace("_" + languageCode, ""));

			return (int)enumConstant;
		}

		/// <summary>
		/// Gets the value corresponding to the option-set's label using its logical name,
		/// the value within, and the language code.
		/// </summary>
		/// <param name="logicalName">The logical name of the option-set in CRM</param>
		/// <param name="label">The label from the option-set</param>
		/// <param name="enumsType">The 'Enums' type; e.g.: 'typeof(Account.Enums)'</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns>The value corresponding to the label</returns>
		public static int GetValue(string logicalName, string label, Type enumsType, int languageCode = 1033)
		{
			var labelType = GetLabelType(enumsType, logicalName);

			return GetValue(labelType, label, languageCode);
		}

		private static Type GetEnumType(Type enumsType, string logicalName)
		{
			var field = GetLogicalNameField(enumsType, logicalName);

			var entityType = enumsType.DeclaringType;

			if (entityType == null)
			{
				throw new Exception("Can't find the entity type from the enum type.");
			}

			return field == null ? null : entityType.GetNestedType(field.Name + "Enum");
		}

		#endregion

		#region Labels

		/// <summary>
		/// Gets the label corresponding to the option-set's value using its logical name,
		/// the value within, and the language code.
		/// </summary>
		/// <param name="logicalName">The logical name of the option-set in CRM</param>
		/// <param name="constant">The value from the option-set</param>
		/// <param name="enumsType">The 'Enums' type; e.g.: 'typeof(Account.Enums)'</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns></returns>
		public static string GetLabel(string logicalName, int constant, Type enumsType, int languageCode = 1033)
		{
			var enumType = GetEnumType(enumsType, logicalName);

			if (enumType == null)
			{
				return null;
			}

			var enumName = enumType.Name;
			var constantName = enumType.GetEnumName(constant);
			var labelsType = enumsType.GetNestedType("Labels");

			if (labelsType == null)
			{
				return null;
			}

			var labelType = labelsType.GetNestedType(enumName.Substring(0, enumType.Name.LastIndexOf("Enum")));

			if (labelType == null)
			{
				return null;
			}

			var field = labelType.GetField(constantName + "_" + languageCode);

			return field == null ? null : field.GetValue(labelType).ToString();
		}

		private static Type GetLabelType(Type enumsType, string logicalName)
		{
			var field = GetLogicalNameField(enumsType, logicalName);
			return enumsType.GetNestedType("Labels").GetNestedType(field.Name);
		}

		#endregion

		private static FieldInfo GetLogicalNameField(Type enumsType, string logicalName)
		{
			var namesType = enumsType.GetNestedType("Names");
			return namesType.GetFields().FirstOrDefault(fieldQ => (string)fieldQ.GetValue(namesType) == logicalName);
		}

		internal static QueryExpression GetLoadRelationQuery(Entity entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string idFieldName, string intersectIdFieldName, int limit = -1, int page = -1, string cookie = null,
			FilterExpression filter = null, params string[] attributes)
		{
			limit = limit <= 0 ? int.MaxValue : limit;

			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity[idFieldName]);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			query.PageInfo = new PagingInfo
			{
				PageNumber = page <= 0 ? 1 : page,
				Count = limit,
				PagingCookie = cookie
			};

			return query;
		}

		internal static List<Entity> LoadRelation(Entity entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string idFieldName, string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, string cookie = null, RelationPagingInfo relationPagingInfo = null, params string[] attributes)
		{
			return LoadRelation(service, GetLoadRelationQuery(entity, service, fromEntityName, toEntityName,
				fromFieldName, toFieldName, idFieldName, intersectIdFieldName, limit, page, cookie,
				filter, attributes), limit, page, cookie, relationPagingInfo);
		}

		public static List<Entity> LoadRelation(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1, string cookie = null, RelationPagingInfo relationPagingInfo = null)
		{
			limit = limit <= 0 ? int.MaxValue : limit;
			query.PageInfo = query.PageInfo ??
				new PagingInfo
				{
					PageNumber = page <= 0 ? 1 : page,
					Count = limit
				};
			query.PageInfo.PagingCookie = cookie ?? relationPagingInfo.Cookie ?? query.PageInfo.PagingCookie;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			} while (records.MoreRecords && entities.Count < limit && page <= 0);

			if (relationPagingInfo != null)
			{
				relationPagingInfo.Cookie = query.PageInfo.PagingCookie;
				relationPagingInfo.NextPage = query.PageInfo.PageNumber;
				relationPagingInfo.IsMoreRecords = records.MoreRecords;
			}

			return entities.ToList();
		}

		/// <summary>
		/// Executes the queries in the query queue in each entity passed, and executes the action related to the query after.<br />
		/// Returns a list of errors per entity processed.
		/// </summary>
		/// <param name="service">CRM service to use to execute query.</param>
		/// <param name="entities">List of entities containing the queues.</param>
		public static IDictionary<GeneratedEntityBase, IList<string>> ProcessDeferredQueries(IOrganizationService service,
			params GeneratedEntityBase[] entities)
		{
            return ProcessDeferredQueries(service, 100, entities);
        }

		/// <summary>
		/// Executes the queries in the query queue in each entity passed, and executes the action related to the query after.<br />
		/// Returns a list of errors per entity processed.
		/// </summary>
		/// <param name="service">CRM service to use to execute query.</param>
		/// <param name="bulkSize">The number of requests from the queue to execute in each iteration.</param>
		/// <param name="entities">List of entities containing the queues.</param>
		internal static IDictionary<GeneratedEntityBase, IList<string>> ProcessDeferredQueries(IOrganizationService service,
			int bulkSize, params GeneratedEntityBase[] entities)
		{
			var errorList = new Dictionary<GeneratedEntityBase, IList<string>>();

			// exit if no entities to process
			if (!entities.Any()) return errorList;
            
            bulkSize = Math.Min(1000, bulkSize);

			// filter entities to only the ones with a queue
			entities = entities.Where(entity => entity.DeferredQueriesList.Any()).ToArray();

			// queue to assign errors to proper entity and to find the original query and invoke the action
			var queryActionQueue = new Queue<KeyValuePair<GeneratedEntityBase, QueryAction>>();

			// create a queue to support paging in bulk execution
			var requestsQueue = new Queue<OrganizationRequest>();

			// go over the entities and fill the queues
			foreach (var entity in entities)
			{
				foreach (var queryAction in entity.DeferredQueriesList)
				{
					queryActionQueue.Enqueue(new KeyValuePair<GeneratedEntityBase, QueryAction>(entity, queryAction));
					requestsQueue.Enqueue(new RetrieveMultipleRequest {Query = queryAction.Query});
				}
			}

			var bulkQuery = new ExecuteMultipleRequest
			{
				Settings = new ExecuteMultipleSettings
				{
					ContinueOnError = true,
					ReturnResponses = true
				},
				Requests = new OrganizationRequestCollection()
			};

			while (requestsQueue.Any())
			{
				bulkQuery.Requests.Clear();

				// page execution
				do
				{
					bulkQuery.Requests.Add(requestsQueue.Dequeue());
				} while (bulkQuery.Requests.Count % bulkSize != 0 && requestsQueue.Any());

				var result = (ExecuteMultipleResponse) service.Execute(bulkQuery);

				foreach (var response in result.Responses)
				{
					var queryAction = queryActionQueue.Dequeue();
					var entity = queryAction.Key;

					// parse fault
					if (response.Fault != null)
					{
						if (!errorList.ContainsKey(entity))
						{
							errorList.Add(entity, new List<string>());
						}

						errorList[entity].Add(string.Format("Error code: {0}.\nError message: {1}.",
							response.Fault.ErrorCode, response.Fault.Message)
													 + (!string.IsNullOrEmpty(response.Fault.TraceText)
															? "\nError trace: " + response.Fault.TraceText
															: ""));

						continue;
					}

					queryAction.Value.Action.Invoke(response.Response);
				}
			}

			return errorList;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
    public class EntityComparer : IEqualityComparer<Entity>
    {
        public bool Equals(Entity x, Entity y)
        {
            return x.Id == y.Id;
        }

        public int GetHashCode(Entity obj)
        {
            return obj.Id.GetHashCode();
        }
    }

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public static class TypeHelpers
	{
		public static Type GetType(string name, Type assemblyScope = null)
		{
			return assemblyScope == null
				? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
					.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
				: assemblyScope.Assembly.GetTypes()
					.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name);
		}
	}

	public partial class EntityContract
	{
		public TCrmEntity ConvertTo<TCrmEntity>(ClearMode? clearMode = null) where TCrmEntity : Entity
		{
			// create CRM entity object
			var crmRecord = Activator.CreateInstance<TCrmEntity>();

			var entityType = GetType();
			var entityLogicalName = entityType.GetCustomAttribute<CrmEntityMappingAttribute>().LogicalName;

			// if logical names don't match
			if (entityLogicalName != crmRecord.LogicalName)
			{
				throw new Exception($"Entity '{entityType.Name}' doesn't map to CRM entity '{typeof(TCrmEntity).Name}'.");
			}

			clearMode = clearMode
				?? (ClearMode?)entityType.GetProperty("ValueClearMode")?.GetValue(this)
					?? ClearMode.Disabled;

			// go over all fields in the contract entity that has the mapping attribute
			foreach (var field in entityType.GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))
					&& !Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = field.GetCustomAttribute<CrmFieldMappingAttribute>();
				// get the value of the field
				var value = field.GetValue(this);
				// is the field value read only
				var isReadOnly = field.GetCustomAttribute<ReadOnlyFieldAttribute>() != null;
				// get the clear flag mode value if it exists
				var isClearFlag = clearMode == ClearMode.Flag
					&& (bool?)entityType.GetProperties().Where(fieldQ => fieldQ.Name == "Clear_" + field.Name)
						.Select(fieldQ => fieldQ.GetValue(this)).FirstOrDefault() == true;
				// check 'empty' mode
				var isClearEmpty = clearMode == ClearMode.Empty;
				var isClearConvention = clearMode == ClearMode.Convention;

				var isSetValue = value != null || isClearFlag || isClearEmpty || isClearConvention;

				// skip if no value and clear mode does not match and pass check
				if (isReadOnly || !isSetValue)
				{
					continue;
				}

				SetValueInCrmRecord(value, crmRecord, field.Name, mapping, clearMode, isClearFlag);
			}

			// go over flattened relations in the contract entity that has the mapping attribute
			foreach (var field in GetType().GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))
					&& Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))))
			{
				// get the value of the field
				var value = field.GetValue(this);
				// is the field value read only
				var isReadOnly = field.GetCustomAttribute<ReadOnlyFieldAttribute>();

				// skip if no value
				if (isReadOnly != null || (value == null && clearMode != ClearMode.Empty) || value is Array)
				{
					continue;
				}

				SetRelationInRecord(value, field);
			}

			// go over all relations in the contract entity that has the mapping attribute
			foreach (var relation in GetType().GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))
					&& !Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = relation.GetCustomAttribute<CrmRelationMappingAttribute>();
				// get the value of the field
				var value = relation.GetValue(this);
				// is the relation read only
				var isReadOnly = relation.GetCustomAttribute<ReadOnlyFieldAttribute>();

				// skip if no value
				if (isReadOnly != null || value == null || (value is Array && ((Array)value).Length <= 0))
				{
					continue;
				}

				SetRelationInCrmRecord(value, crmRecord, mapping, clearMode);
			}

			return crmRecord;
		}

		private void SetRelationInRecord(object value, PropertyInfo propertyInfo)
		{
			// get the property representing the relationship
			var relation = GetType().GetProperties()
				.Where(fQ => !Attribute.IsDefined(fQ, typeof(CrmFieldMappingAttribute))
					&& Attribute.IsDefined(fQ, typeof(CrmRelationMappingAttribute)))
				.FirstOrDefault(
					fQ =>
					{
						var rAttr = fQ.GetCustomAttribute<CrmRelationMappingAttribute>();
						var relationAttr = propertyInfo.GetCustomAttribute<CrmRelationMappingAttribute>();
						return rAttr.SchemaName == relationAttr.SchemaName && rAttr.Role == relationAttr.Role;
					});

			if (relation == null)
			{
				return;
			}

			// get the related entity type
			var type = relation.PropertyType;
			// get the target property in the related entity to set the value
			var mappedProperty = type.GetProperties()
				.Where(fQ => Attribute.IsDefined(fQ, typeof(CrmFieldMappingAttribute))
					&& !Attribute.IsDefined(fQ, typeof(CrmRelationMappingAttribute)))
				.FirstOrDefault(p => p.GetCustomAttribute<CrmFieldMappingAttribute>().LogicalName
					== propertyInfo.GetCustomAttribute<CrmFieldMappingAttribute>().LogicalName);

			if (mappedProperty == null)
			{
				return;
			}

			// get the relation value
			var record = relation.GetValue(this);

			if (record == null)
			{
				// create a new instance of the related entity if it's null
				record = Activator.CreateInstance(type);
				// save the relation object in this entity
				relation.SetValue(this, record);
			}

			// set the field value in the related record
			mappedProperty.SetValue(record, value);
		}

		private static void SetValueInCrmRecord<TCrmEntity>(object value, TCrmEntity crmRecord,
			string fieldName, CrmFieldMappingAttribute mapping, ClearMode? clearMode = null, bool isClearFlag = false)
			where TCrmEntity : Entity
		{
			var crmProperty = GetCrmProperty<TCrmEntity>(mapping);

			if (crmProperty == null)
			{
				return;
			}
            
			// if no value, and clear mode is global or flagged, then clear
			if (value == null && (clearMode == ClearMode.Empty || isClearFlag))
			{
				crmRecord[mapping.LogicalName] = null;
			}
            
			// convert types
			if (value is Enum)
			{
			    // if clear mode is convention, and value fits convention, then clear
				var intVal = Convert.ToInt32(value);
				crmRecord[mapping.LogicalName] =
					(intVal == -1 && clearMode == ClearMode.Convention)
						? null
						: new OptionSetValue(intVal);
			}
			else if (value is decimal && crmProperty.PropertyType == typeof(Money))
			{
				crmRecord[mapping.LogicalName] =
					(value.Equals(decimal.MinValue) && clearMode == ClearMode.Convention)
						? null
						: new Money(((decimal?)value).Value);
			}
			else if (value is Guid && fieldName != "Id" && crmProperty.PropertyType == typeof(Guid?))
			{
				crmProperty.SetValue(crmRecord,
					(value.Equals(Guid.Empty) && clearMode == ClearMode.Convention)
						? null
						: (Guid?)value);
			}
			else if (value is LookupValue)
			{
				var lookupValue = (LookupValue)value;

				if (crmProperty.PropertyType == typeof(LookupValue))
				{
					crmProperty.SetValue(crmRecord,
						(lookupValue.Id.Equals(Guid.Empty) && clearMode == ClearMode.Convention)
							? null
							: value);
				}
				else if (crmProperty.PropertyType == typeof(EntityReference))
				{
					crmProperty.SetValue(crmRecord,
						(lookupValue.Id.Equals(Guid.Empty) && clearMode == ClearMode.Convention)
							? null
							: new EntityReference(lookupValue.EntityName, lookupValue.Id));
				}
			}
			else
			{
			    // if clear mode is convention, and value fits convention, then clear
			    if (clearMode == ClearMode.Convention
                    && ((value is DateTime && value.Equals(new DateTime(1970, 1, 1)))
                        || (value is int && value.Equals(int.MinValue))
                        || (value is long && value.Equals(long.MinValue))
                        || (value is decimal && value.Equals(decimal.MinValue))
                        || (value is double && value.Equals(double.MinValue))
                        || (value is Array && (value as Array).Length <= 0)
                        || (value is string && value.Equals(""))))
			    {
				    crmProperty.SetValue(crmRecord, null);
			    }
                else
				{
                    crmProperty.SetValue(crmRecord, value);
                }
			}
		}

		/// <summary>
		///     Gets the property from the CRM entity that corresponds to this field -- same mapping
		/// </summary>
		/// <typeparam name="TCrmEntity">The type of the entity.</typeparam>
		/// <param name="mapping">The mapping.</param>
		/// <returns></returns>
		private static PropertyInfo GetCrmProperty<TCrmEntity>(CrmFieldMappingAttribute mapping)
			where TCrmEntity : Entity
		{
			var crmProperty = typeof(TCrmEntity).GetProperties()
				.FirstOrDefault(propertyQ =>
								{
									var fieldAttribute = propertyQ
										.GetCustomAttributes<AttributeLogicalNameAttribute>(true)
										.FirstOrDefault();

									return fieldAttribute != null
										   && fieldAttribute.LogicalName == mapping.LogicalName;
								});

			return crmProperty;
		}

		private static void SetRelationInCrmRecord<TCrmEntity>(object value, TCrmEntity crmRecord,
			CrmRelationMappingAttribute mapping, ClearMode? clearMode = null)
			where TCrmEntity : Entity
		{
			var crmRelation = GetCrmRelation<TCrmEntity>(mapping);

			// if relation not found, then the entities don't map correctly
			if (crmRelation == null)
			{
				throw new Exception($"Entity doesn't map to CRM entity '{typeof(TCrmEntity).Name}'.");
			}

			object convertedValue = null;

			var type = TypeHelpers.GetType(mapping.RelatedEntityName);

			if (type == null)
			{
				throw new TypeLoadException($"Could not find type {mapping.RelatedEntityName} to convert contract record.");
			}

			// x-N relation
			if (value is Array)
			{
				var relatedRecords = (Array)value;
				// create an array for the related entities of the appropriate type
				var crmRelatedRecords = Array.CreateInstance(type, relatedRecords.Length);

				// create the method reference that will be used to convert the related entities to the CRM entities
				var method = GetConversionMethod(relatedRecords.GetValue(0), type);

				if (method == null)
				{
					return;
				}

				// convert all entities to CRM entities
				var objectCrmRelatedRecords =
					(from object relatedRecord in relatedRecords
					 select method.Invoke(relatedRecord, new object[] { clearMode })).ToArray();

				// copy the object entities to the array of the specific type
				Array.Copy(objectCrmRelatedRecords, crmRelatedRecords, crmRelatedRecords.Length);
				convertedValue = crmRelatedRecords;
			}
			else if (value is EntityContract)
			{
				// N-1 relation
				var method = GetConversionMethod(value, type);

				if (method == null)
				{
					return;
				}

				convertedValue = method.Invoke(value, new object[] { clearMode });
			}

			// set the related entities value in the CRM entity
			crmRelation.SetValue(crmRecord, convertedValue);
		}

		private static MethodInfo GetConversionMethod(object entity, Type relatedType)
		{
			return entity.GetType().GetMethod("ConvertTo")?.MakeGenericMethod(relatedType);
		}

		/// <summary>
		///     Gets the relation from the CRM entity that corresponds to this relation -- same mapping
		/// </summary>
		/// <typeparam name="TCrmEntity">The type of the entity.</typeparam>
		/// <param name="mapping">The mapping.</param>
		/// <returns></returns>
		private static PropertyInfo GetCrmRelation<TCrmEntity>(CrmRelationMappingAttribute mapping)
			where TCrmEntity : Entity
		{
			var crmRelation = typeof(TCrmEntity).GetProperties()
				.FirstOrDefault(propertyQ =>
								{
									var relationAttribute = propertyQ
										.GetCustomAttributes<RelationshipSchemaNameAttribute>(true)
										.FirstOrDefault();

									return relationAttribute != null
										   && relationAttribute.SchemaName == mapping.SchemaName
										   && relationAttribute.PrimaryEntityRole == (EntityRole?)mapping.Role;
								});

			return crmRelation;
		}
	}

	#endregion


	#region Actions

	#endregion

	#region Known Types

	#endregion


	#region Boiler

	/// <summary>
	/// 'chpqa_Boiler'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_boiler")]
	public partial class Boiler : GeneratedEntity<Boiler.RelationName>
	{
		public Boiler() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Boiler(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Boiler(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Boiler";
		public const string SchemaName = "chpqa_Boiler";
		public const string EntityLogicalName = "chpqa_boiler";
		public const int EntityTypeCode = 10641;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_boilerid")]
		public override System.Guid Id
		{
			get => (BoilerId == null || BoilerId == Guid.Empty) ? base.Id : BoilerId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_boilerid");
                    base.Id = value;
                } else {
				    BoilerId = value;
                }
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_BoilerId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_boilerid")]
		public Guid? BoilerId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_boilerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_boilerid"))
				    value = (Guid?) backupAttributeCollection["chpqa_boilerid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_boilerid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_details"), Required, MaxLength(100), StringLength(100)]
		public string Details
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_details");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_details"))
				    value = (string) backupAttributeCollection["chpqa_details"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_details", value);
			}
		}

		[AttributeLogicalName("chpqa_manufacturer"), Required]
		public Guid? Manufacturer
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_manufacturer");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturer"))
				    value = (EntityReference) backupAttributeCollection["chpqa_manufacturer"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_manufacturer", new EntityReference("chpqa_manufacturer", value.Value));
                else
	                SetAttributeValue("chpqa_manufacturer", value);
			}
		}

        public string ManufacturerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_manufacturer");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturer"))
				    value = (EntityReference) backupAttributeCollection["chpqa_manufacturer"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturer")]
        public IDictionary<int, string> ManufacturerLabels { get; set; }

		[AttributeLogicalName("chpqa_maximumratedheat"), Required, MaxLength(100), StringLength(100)]
		public string MaximumRatedHeat
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_maximumratedheat");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_maximumratedheat"))
				    value = (string) backupAttributeCollection["chpqa_maximumratedheat"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_maximumratedheat", value);
			}
		}

		[AttributeLogicalName("chpqa_maximumratedpower"), Required, MaxLength(100), StringLength(100)]
		public string MaximumRatedPower
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_maximumratedpower");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_maximumratedpower"))
				    value = (string) backupAttributeCollection["chpqa_maximumratedpower"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_maximumratedpower", value);
			}
		}

		[AttributeLogicalName("chpqa_model"), Required]
		public Guid? Model
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_model");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_model"))
				    value = (EntityReference) backupAttributeCollection["chpqa_model"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_model", new EntityReference("chpqa_model", value.Value));
                else
	                SetAttributeValue("chpqa_model", value);
			}
		}

        public string ModelName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_model");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_model"))
				    value = (EntityReference) backupAttributeCollection["chpqa_model"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_model", "chpqa_modelid", "chpqa_model")]
        public IDictionary<int, string> ModelLabels { get; set; }

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_scheme"), Required]
		public Guid? Scheme
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_scheme", new EntityReference("chpqa_scheme", value.Value));
                else
	                SetAttributeValue("chpqa_scheme", value);
			}
		}

        public string SchemeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_ref", "chpqa_scheme", "chpqa_schemeid", "chpqa_scheme")]
        public IDictionary<int, string> SchemeLabels { get; set; }

		[AttributeLogicalName("chpqa_submission")]
		public Guid? Submission
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_submission", new EntityReference("chpqa_submission", value.Value));
                else
	                SetAttributeValue("chpqa_submission", value);
			}
		}

        public string SubmissionName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_submission", "chpqa_submissionid", "chpqa_submission")]
        public IDictionary<int, string> SubmissionLabels { get; set; }

		[AttributeLogicalName("chpqa_tagnumber"), Required, Range(0,256)]
		public int? TagNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("chpqa_tagnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_tagnumber"))
				    value = (int?) backupAttributeCollection["chpqa_tagnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_tagnumber", value);
			}
		}

		[AttributeLogicalName("chpqa_type"), Required]
		public Guid? Type
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_type");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_type"))
				    value = (EntityReference) backupAttributeCollection["chpqa_type"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_type", new EntityReference("chpqa_boilertype", value.Value));
                else
	                SetAttributeValue("chpqa_type", value);
			}
		}

        public string TypeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_type");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_type"))
				    value = (EntityReference) backupAttributeCollection["chpqa_type"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_boilertype", "chpqa_boilertypeid", "chpqa_type")]
        public IDictionary<int, string> TypeLabels { get; set; }

		[AttributeLogicalName("chpqa_yearcommissioned"), Required, Range(1990,2200)]
		public int? YearCommissioned
		{
			get
			{
				var value = GetAttributeValue<int?>("chpqa_yearcommissioned");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_yearcommissioned"))
				    value = (int?) backupAttributeCollection["chpqa_yearcommissioned"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_yearcommissioned", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Boiler
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Boiler
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// N:1, 'chpqa_Boiler_chpqa_Submission_chpqa_Submi'
		/// </summary>
		[RelationshipSchemaName("chpqa_Boiler_chpqa_Submission_chpqa_Submi"), AttributeLogicalName("chpqa_submission")]
		public Submission SubmissionAsSubmission
		{
			get => GetRelatedEntity<Submission>("chpqa_Boiler_chpqa_Submission_chpqa_Submi", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Submission>("chpqa_Boiler_chpqa_Submission_chpqa_Submi", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_boilerid", "chpqa_boilerid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_Boiler_chpqa_Submission_chpqa_Submi"), alreadyTracked); } catch { }
			if (SubmissionAsSubmission == null || SubmissionAsSubmission.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Submission>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Submission result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_boilerid", "chpqa_boilerid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SubmissionAsSubmission = result = (resultTemp == null ? null : resultTemp.ToEntity<Submission>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu"), AttributeLogicalName("chpqa_manufacturer")]
		public Manufacturer ManufacturerAsManufacturer
		{
			get => GetRelatedEntity<Manufacturer>("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Manufacturer>("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Manufacturer LoadManufacturerAsManufacturer(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_manufacturer", LogicalName, "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_boilerid", "chpqa_boilerid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu"), alreadyTracked); } catch { }
			if (ManufacturerAsManufacturer == null || ManufacturerAsManufacturer.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Manufacturer>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Manufacturer LoadManufacturerAsManufacturer(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Manufacturer result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_manufacturer", LogicalName, "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_boilerid", "chpqa_boilerid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					ManufacturerAsManufacturer = result = (resultTemp == null ? null : resultTemp.ToEntity<Manufacturer>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_boiler_Model_chpqa_model'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Model_chpqa_model"), AttributeLogicalName("chpqa_model")]
		public Model ModelAsModel
		{
			get => GetRelatedEntity<Model>("chpqa_chpqa_boiler_Model_chpqa_model", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Model>("chpqa_chpqa_boiler_Model_chpqa_model", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Model LoadModelAsModel(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_model", LogicalName, "chpqa_modelid", "chpqa_model", "chpqa_boilerid", "chpqa_boilerid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Model_chpqa_model"), alreadyTracked); } catch { }
			if (ModelAsModel == null || ModelAsModel.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Model>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Model LoadModelAsModel(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Model result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_model", LogicalName, "chpqa_modelid", "chpqa_model", "chpqa_boilerid", "chpqa_boilerid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					ModelAsModel = result = (resultTemp == null ? null : resultTemp.ToEntity<Model>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_boiler_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Scheme_chpqa_scheme"), AttributeLogicalName("chpqa_scheme")]
		public Scheme SchemeAsScheme
		{
			get => GetRelatedEntity<Scheme>("chpqa_chpqa_boiler_Scheme_chpqa_scheme", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Scheme>("chpqa_chpqa_boiler_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_boilerid", "chpqa_boilerid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			if (SchemeAsScheme == null || SchemeAsScheme.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Scheme>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Scheme result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_boilerid", "chpqa_boilerid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SchemeAsScheme = result = (resultTemp == null ? null : resultTemp.ToEntity<Scheme>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_boiler_Type_chpqa_boilertype'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Type_chpqa_boilertype"), AttributeLogicalName("chpqa_type")]
		public BoilerType BoilerTypeAsType
		{
			get => GetRelatedEntity<BoilerType>("chpqa_chpqa_boiler_Type_chpqa_boilertype", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<BoilerType>("chpqa_chpqa_boiler_Type_chpqa_boilertype", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public BoilerType LoadBoilerTypeAsType(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_boilertype", LogicalName, "chpqa_boilertypeid", "chpqa_type", "chpqa_boilerid", "chpqa_boilerid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Type_chpqa_boilertype"), alreadyTracked); } catch { }
			if (BoilerTypeAsType == null || BoilerTypeAsType.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<BoilerType>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public BoilerType LoadBoilerTypeAsType(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			BoilerType result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_boilertype", LogicalName, "chpqa_boilertypeid", "chpqa_type", "chpqa_boilerid", "chpqa_boilerid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					BoilerTypeAsType = result = (resultTemp == null ? null : resultTemp.ToEntity<BoilerType>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName SubmissionAsSubmission = new RelationName("SubmissionAsSubmission");
			public static RelationName ManufacturerAsManufacturer = new RelationName("ManufacturerAsManufacturer");
			public static RelationName ModelAsModel = new RelationName("ModelAsModel");
			public static RelationName SchemeAsScheme = new RelationName("SchemeAsScheme");
			public static RelationName BoilerTypeAsType = new RelationName("BoilerTypeAsType");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["SubmissionAsSubmission"] = new object[] { "SubmissionAsSubmission", "chpqa_submission", "chpqa_boiler", "chpqa_submissionid", "chpqa_submission", "chpqa_boilerid", "chpqa_boilerid", "chpqa_Boiler_chpqa_Submission_chpqa_Submi", typeof (Submission) };
			relationProperties["ManufacturerAsManufacturer"] = new object[] { "ManufacturerAsManufacturer", "chpqa_manufacturer", "chpqa_boiler", "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_boilerid", "chpqa_boilerid", "chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu", typeof (Manufacturer) };
			relationProperties["ModelAsModel"] = new object[] { "ModelAsModel", "chpqa_model", "chpqa_boiler", "chpqa_modelid", "chpqa_model", "chpqa_boilerid", "chpqa_boilerid", "chpqa_chpqa_boiler_Model_chpqa_model", typeof (Model) };
			relationProperties["SchemeAsScheme"] = new object[] { "SchemeAsScheme", "chpqa_scheme", "chpqa_boiler", "chpqa_schemeid", "chpqa_scheme", "chpqa_boilerid", "chpqa_boilerid", "chpqa_chpqa_boiler_Scheme_chpqa_scheme", typeof (Scheme) };
			relationProperties["BoilerTypeAsType"] = new object[] { "BoilerTypeAsType", "chpqa_boilertype", "chpqa_boiler", "chpqa_boilertypeid", "chpqa_type", "chpqa_boilerid", "chpqa_boilerid", "chpqa_chpqa_boiler_Type_chpqa_boilertype", typeof (BoilerType) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Boiler(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_boilerid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string BoilerId = "chpqa_boilerid";
			public const string Details = "chpqa_details";
			public const string Manufacturer = "chpqa_manufacturer";
			public const string MaximumRatedHeat = "chpqa_maximumratedheat";
			public const string MaximumRatedPower = "chpqa_maximumratedpower";
			public const string Model = "chpqa_model";
			public const string Name = "chpqa_name";
			public const string Scheme = "chpqa_scheme";
			public const string Submission = "chpqa_submission";
			public const string TagNumber = "chpqa_tagnumber";
			public const string Type = "chpqa_type";
			public const string YearCommissioned = "chpqa_yearcommissioned";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string BoilerId = "chpqa_BoilerId";
				public const string Details = "chpqa_Details";
				public const string Manufacturer = "chpqa_Manufacturer";
				public const string MaximumRatedHeat = "chpqa_MaximumRatedHeat";
				public const string MaximumRatedPower = "chpqa_MaximumRatedPower";
				public const string Model = "chpqa_Model";
				public const string Name = "chpqa_Name";
				public const string Scheme = "chpqa_Scheme";
				public const string Submission = "chpqa_Submission";
				public const string TagNumber = "chpqa_TagNumber";
				public const string Type = "chpqa_Type";
				public const string YearCommissioned = "chpqa_YearCommissioned";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> BoilerId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Boiler"},
					};

				public static IDictionary<int, string> Details { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Details"},
					};

				public static IDictionary<int, string> Manufacturer { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Manufacturer"},
					};

				public static IDictionary<int, string> MaximumRatedHeat { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Maximum Rated Heat"},
					};

				public static IDictionary<int, string> MaximumRatedPower { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Maximum Rated Power"},
					};

				public static IDictionary<int, string> Model { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Model"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> Scheme { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme"},
					};

				public static IDictionary<int, string> Submission { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Submission"},
					};

				public static IDictionary<int, string> TagNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Tag Number"},
					};

				public static IDictionary<int, string> Type { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Type"},
					};

				public static IDictionary<int, string> YearCommissioned { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Year Commissioned"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
			}
			
			public static class NToOne
			{
				public const string SubmissionAsSubmission = "chpqa_Boiler_chpqa_Submission_chpqa_Submi";
				public const string ManufacturerAsManufacturer = "chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu";
				public const string ModelAsModel = "chpqa_chpqa_boiler_Model_chpqa_model";
				public const string SchemeAsScheme = "chpqa_chpqa_boiler_Scheme_chpqa_scheme";
				public const string BoilerTypeAsType = "chpqa_chpqa_boiler_Type_chpqa_boilertype";

				public static class Lookups
				{
					public const string SubmissionAsSubmission = "chpqa_submission";
					public const string ManufacturerAsManufacturer = "chpqa_manufacturer";
					public const string ModelAsModel = "chpqa_model";
					public const string SchemeAsScheme = "chpqa_scheme";
					public const string BoilerTypeAsType = "chpqa_type";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region BoilerType

	/// <summary>
	/// 'chpqa_BoilerType'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_boilertype")]
	public partial class BoilerType : GeneratedEntity<BoilerType.RelationName>
	{
		public BoilerType() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public BoilerType(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public BoilerType(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Boiler Type";
		public const string SchemaName = "chpqa_BoilerType";
		public const string EntityLogicalName = "chpqa_boilertype";
		public const int EntityTypeCode = 10795;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_boilertypeid")]
		public override System.Guid Id
		{
			get => (BoilerTypeId == null || BoilerTypeId == Guid.Empty) ? base.Id : BoilerTypeId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_boilertypeid");
                    base.Id = value;
                } else {
				    BoilerTypeId = value;
                }
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_BoilerTypeId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_boilertypeid")]
		public Guid? BoilerTypeId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_boilertypeid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_boilertypeid"))
				    value = (Guid?) backupAttributeCollection["chpqa_boilertypeid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_boilertypeid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Boiler Type
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Boiler Type
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_boiler_Type_chpqa_boilertype'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Type_chpqa_boilertype")]
		public Boiler[] BoilersOfType
		{
			get => GetRelatedEntities<Boiler>("chpqa_chpqa_boiler_Type_chpqa_boilertype", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_boiler_Type_chpqa_boilertype", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Boiler[] LoadBoilersOfType(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_boiler", LogicalName, "chpqa_type", "chpqa_boilertypeid", "chpqa_boilertypeid", "chpqa_boilertypeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Boiler>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Type_chpqa_boilertype"), alreadyTracked); } catch { }
			    });
			if (BoilersOfType == null || BoilersOfType.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Boiler[] LoadBoilersOfType(IOrganizationService service, params string[] attributes)
		{
			return LoadBoilersOfType(service, -1, -1, null, false, attributes);
		}

		public Boiler[] LoadBoilersOfType(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadBoilersOfType(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Boiler[] LoadBoilersOfType(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Boiler[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_boiler", LogicalName, "chpqa_type", "chpqa_boilertypeid", "chpqa_boilertypeid", "chpqa_boilertypeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (BoilersOfType == null) { BoilersOfType = resultArray; return; }
					BoilersOfType = BoilersOfType.Union(resultArray).Distinct<Boiler>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		public static class RelationNames {
			public static RelationName BoilersOfType = new RelationName("BoilersOfType");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["BoilersOfType"] = new object[] { "BoilersOfType", "chpqa_boiler", "chpqa_boilertype", "chpqa_type", "chpqa_boilertypeid", "chpqa_boilertypeid", "chpqa_boilertypeid", "chpqa_chpqa_boiler_Type_chpqa_boilertype", typeof (Boiler[]) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public BoilerType(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_boilertypeid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string BoilerTypeId = "chpqa_boilertypeid";
			public const string Name = "chpqa_name";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string BoilerTypeId = "chpqa_BoilerTypeId";
				public const string Name = "chpqa_Name";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> BoilerTypeId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Boiler Type"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string BoilersOfType = "chpqa_chpqa_boiler_Type_chpqa_boilertype";
			}
			
			public static class NToOne
			{

				public static class Lookups
				{
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Diagram

	/// <summary>
	/// 'chpqa_Diagram'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_diagram")]
	public partial class Diagram : GeneratedEntity<Diagram.RelationName>
	{
		public Diagram() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Diagram(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Diagram(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Diagram";
		public const string SchemaName = "chpqa_Diagram";
		public const string EntityLogicalName = "chpqa_diagram";
		public const int EntityTypeCode = 10601;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_diagramid")]
		public override System.Guid Id
		{
			get => (DiagramId == null || DiagramId == Guid.Empty) ? base.Id : DiagramId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_diagramid");
                    base.Id = value;
                } else {
				    DiagramId = value;
                }
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_DiagramId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_diagramid")]
		public Guid? DiagramId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_diagramid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_diagramid"))
				    value = (Guid?) backupAttributeCollection["chpqa_diagramid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_diagramid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_filename"), MaxLength(300), StringLength(300)]
		public string Filename
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_filename");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_filename"))
				    value = (string) backupAttributeCollection["chpqa_filename"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_filename", value);
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_scheme"), Required]
		public Guid? Scheme
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_scheme", new EntityReference("chpqa_scheme", value.Value));
                else
	                SetAttributeValue("chpqa_scheme", value);
			}
		}

        public string SchemeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_ref", "chpqa_scheme", "chpqa_schemeid", "chpqa_scheme")]
        public IDictionary<int, string> SchemeLabels { get; set; }

		[AttributeLogicalName("chpqa_submission")]
		public Guid? Submission
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_submission", new EntityReference("chpqa_submission", value.Value));
                else
	                SetAttributeValue("chpqa_submission", value);
			}
		}

        public string SubmissionName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_submission", "chpqa_submissionid", "chpqa_submission")]
        public IDictionary<int, string> SubmissionLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Diagram
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Diagram
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// N:1, 'chpqa_chpqa_diagram_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_diagram_Scheme_chpqa_scheme"), AttributeLogicalName("chpqa_scheme")]
		public Scheme SchemeAsScheme
		{
			get => GetRelatedEntity<Scheme>("chpqa_chpqa_diagram_Scheme_chpqa_scheme", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Scheme>("chpqa_chpqa_diagram_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_diagramid", "chpqa_diagramid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_diagram_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			if (SchemeAsScheme == null || SchemeAsScheme.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Scheme>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Scheme result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_diagramid", "chpqa_diagramid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SchemeAsScheme = result = (resultTemp == null ? null : resultTemp.ToEntity<Scheme>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_Diagram_chpqa_Submission_chpqa_Subm'
		/// </summary>
		[RelationshipSchemaName("chpqa_Diagram_chpqa_Submission_chpqa_Subm"), AttributeLogicalName("chpqa_submission")]
		public Submission SubmissionAsSubmission
		{
			get => GetRelatedEntity<Submission>("chpqa_Diagram_chpqa_Submission_chpqa_Subm", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Submission>("chpqa_Diagram_chpqa_Submission_chpqa_Subm", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_diagramid", "chpqa_diagramid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_Diagram_chpqa_Submission_chpqa_Subm"), alreadyTracked); } catch { }
			if (SubmissionAsSubmission == null || SubmissionAsSubmission.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Submission>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Submission result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_diagramid", "chpqa_diagramid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SubmissionAsSubmission = result = (resultTemp == null ? null : resultTemp.ToEntity<Submission>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName SchemeAsScheme = new RelationName("SchemeAsScheme");
			public static RelationName SubmissionAsSubmission = new RelationName("SubmissionAsSubmission");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["SchemeAsScheme"] = new object[] { "SchemeAsScheme", "chpqa_scheme", "chpqa_diagram", "chpqa_schemeid", "chpqa_scheme", "chpqa_diagramid", "chpqa_diagramid", "chpqa_chpqa_diagram_Scheme_chpqa_scheme", typeof (Scheme) };
			relationProperties["SubmissionAsSubmission"] = new object[] { "SubmissionAsSubmission", "chpqa_submission", "chpqa_diagram", "chpqa_submissionid", "chpqa_submission", "chpqa_diagramid", "chpqa_diagramid", "chpqa_Diagram_chpqa_Submission_chpqa_Subm", typeof (Submission) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Diagram(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_diagramid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string DiagramId = "chpqa_diagramid";
			public const string Filename = "chpqa_filename";
			public const string Name = "chpqa_name";
			public const string Scheme = "chpqa_scheme";
			public const string Submission = "chpqa_submission";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string DiagramId = "chpqa_DiagramId";
				public const string Filename = "chpqa_Filename";
				public const string Name = "chpqa_Name";
				public const string Scheme = "chpqa_Scheme";
				public const string Submission = "chpqa_Submission";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> DiagramId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Diagram"},
					};

				public static IDictionary<int, string> Filename { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Filename"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> Scheme { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme"},
					};

				public static IDictionary<int, string> Submission { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Submission"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
			}
			
			public static class NToOne
			{
				public const string SchemeAsScheme = "chpqa_chpqa_diagram_Scheme_chpqa_scheme";
				public const string SubmissionAsSubmission = "chpqa_Diagram_chpqa_Submission_chpqa_Subm";

				public static class Lookups
				{
					public const string SchemeAsScheme = "chpqa_scheme";
					public const string SubmissionAsSubmission = "chpqa_submission";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Fuel

	/// <summary>
	/// 'chpqa_Fuel'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_fuel")]
	public partial class Fuel : GeneratedEntity<Fuel.RelationName>
	{
		public Fuel() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Fuel(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Fuel(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Fuel";
		public const string SchemaName = "chpqa_Fuel";
		public const string EntityLogicalName = "chpqa_fuel";
		public const int EntityTypeCode = 10617;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_fuelid")]
		public override System.Guid Id
		{
			get => (FuelId == null || FuelId == Guid.Empty) ? base.Id : FuelId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_fuelid");
                    base.Id = value;
                } else {
				    FuelId = value;
                }
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_FuelId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_fuelid")]
		public Guid? FuelId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_fuelid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelid"))
				    value = (Guid?) backupAttributeCollection["chpqa_fuelid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_fuelid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Fuel
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Fuel
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_primemover_Fuel_chpqa_fuel'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Fuel_chpqa_fuel")]
		public PrimeMover[] PrimeMoversOfFuel
		{
			get => GetRelatedEntities<PrimeMover>("chpqa_chpqa_primemover_Fuel_chpqa_fuel", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_primemover_Fuel_chpqa_fuel", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfFuel(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemover", LogicalName, "chpqa_fuel", "chpqa_fuelid", "chpqa_fuelid", "chpqa_fuelid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<PrimeMover>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Fuel_chpqa_fuel"), alreadyTracked); } catch { }
			    });
			if (PrimeMoversOfFuel == null || PrimeMoversOfFuel.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public PrimeMover[] LoadPrimeMoversOfFuel(IOrganizationService service, params string[] attributes)
		{
			return LoadPrimeMoversOfFuel(service, -1, -1, null, false, attributes);
		}

		public PrimeMover[] LoadPrimeMoversOfFuel(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadPrimeMoversOfFuel(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfFuel(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			PrimeMover[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemover", LogicalName, "chpqa_fuel", "chpqa_fuelid", "chpqa_fuelid", "chpqa_fuelid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (PrimeMoversOfFuel == null) { PrimeMoversOfFuel = resultArray; return; }
					PrimeMoversOfFuel = PrimeMoversOfFuel.Union(resultArray).Distinct<PrimeMover>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		public static class RelationNames {
			public static RelationName PrimeMoversOfFuel = new RelationName("PrimeMoversOfFuel");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["PrimeMoversOfFuel"] = new object[] { "PrimeMoversOfFuel", "chpqa_primemover", "chpqa_fuel", "chpqa_fuel", "chpqa_fuelid", "chpqa_fuelid", "chpqa_fuelid", "chpqa_chpqa_primemover_Fuel_chpqa_fuel", typeof (PrimeMover[]) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Fuel(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_fuelid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string FuelId = "chpqa_fuelid";
			public const string Name = "chpqa_name";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string FuelId = "chpqa_FuelId";
				public const string Name = "chpqa_Name";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> FuelId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string PrimeMoversOfFuel = "chpqa_chpqa_primemover_Fuel_chpqa_fuel";
			}
			
			public static class NToOne
			{

				public static class Lookups
				{
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region FuelCategory

	/// <summary>
	/// 'chpqa_FuelCategory'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_fuelcategory")]
	public partial class FuelCategory : GeneratedEntity<FuelCategory.RelationName>
	{
		public FuelCategory() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public FuelCategory(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public FuelCategory(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Fuel Category";
		public const string SchemaName = "chpqa_FuelCategory";
		public const string EntityLogicalName = "chpqa_fuelcategory";
		public const int EntityTypeCode = 10597;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_fuelcategoryid")]
		public override System.Guid Id
		{
			get => (FuelCategoryId == null || FuelCategoryId == Guid.Empty) ? base.Id : FuelCategoryId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_fuelcategoryid");
                    base.Id = value;
                } else {
				    FuelCategoryId = value;
                }
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_FuelCategoryId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_fuelcategoryid")]
		public Guid? FuelCategoryId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_fuelcategoryid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelcategoryid"))
				    value = (Guid?) backupAttributeCollection["chpqa_fuelcategoryid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_fuelcategoryid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Fuel Category
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Fuel Category
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_fueltype_Category_chpqa_fuelcategor'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor")]
		public FuelType[] FuelTypesOfCategory
		{
			get => GetRelatedEntities<FuelType>("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public FuelType[] LoadFuelTypesOfCategory(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_fueltype", LogicalName, "chpqa_category", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<FuelType>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor"), alreadyTracked); } catch { }
			    });
			if (FuelTypesOfCategory == null || FuelTypesOfCategory.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public FuelType[] LoadFuelTypesOfCategory(IOrganizationService service, params string[] attributes)
		{
			return LoadFuelTypesOfCategory(service, -1, -1, null, false, attributes);
		}

		public FuelType[] LoadFuelTypesOfCategory(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadFuelTypesOfCategory(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public FuelType[] LoadFuelTypesOfCategory(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			FuelType[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_fueltype", LogicalName, "chpqa_category", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<FuelType>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<FuelType>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (FuelTypesOfCategory == null) { FuelTypesOfCategory = resultArray; return; }
					FuelTypesOfCategory = FuelTypesOfCategory.Union(resultArray).Distinct<FuelType>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu")]
		public MeterReadings[] MeterReadingssOfFuelCategory
		{
			get => GetRelatedEntities<MeterReadings>("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public MeterReadings[] LoadMeterReadingssOfFuelCategory(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_meterreadings", LogicalName, "chpqa_fuelcategory", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<MeterReadings>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu"), alreadyTracked); } catch { }
			    });
			if (MeterReadingssOfFuelCategory == null || MeterReadingssOfFuelCategory.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public MeterReadings[] LoadMeterReadingssOfFuelCategory(IOrganizationService service, params string[] attributes)
		{
			return LoadMeterReadingssOfFuelCategory(service, -1, -1, null, false, attributes);
		}

		public MeterReadings[] LoadMeterReadingssOfFuelCategory(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadMeterReadingssOfFuelCategory(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public MeterReadings[] LoadMeterReadingssOfFuelCategory(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			MeterReadings[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_meterreadings", LogicalName, "chpqa_fuelcategory", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<MeterReadings>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<MeterReadings>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (MeterReadingssOfFuelCategory == null) { MeterReadingssOfFuelCategory = resultArray; return; }
					MeterReadingssOfFuelCategory = MeterReadingssOfFuelCategory.Union(resultArray).Distinct<MeterReadings>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		public static class RelationNames {
			public static RelationName FuelTypesOfCategory = new RelationName("FuelTypesOfCategory");
			public static RelationName MeterReadingssOfFuelCategory = new RelationName("MeterReadingssOfFuelCategory");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["FuelTypesOfCategory"] = new object[] { "FuelTypesOfCategory", "chpqa_fueltype", "chpqa_fuelcategory", "chpqa_category", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_chpqa_fueltype_Category_chpqa_fuelcategor", typeof (FuelType[]) };
			relationProperties["MeterReadingssOfFuelCategory"] = new object[] { "MeterReadingssOfFuelCategory", "chpqa_meterreadings", "chpqa_fuelcategory", "chpqa_fuelcategory", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_fuelcategoryid", "chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu", typeof (MeterReadings[]) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public FuelCategory(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_fuelcategoryid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string FuelCategoryId = "chpqa_fuelcategoryid";
			public const string Name = "chpqa_name";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string FuelCategoryId = "chpqa_FuelCategoryId";
				public const string Name = "chpqa_Name";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> FuelCategoryId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel Category"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string FuelTypesOfCategory = "chpqa_chpqa_fueltype_Category_chpqa_fuelcategor";
				public const string MeterReadingssOfFuelCategory = "chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu";
			}
			
			public static class NToOne
			{

				public static class Lookups
				{
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region FuelType

	/// <summary>
	/// 'chpqa_FuelType'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_fueltype")]
	public partial class FuelType : GeneratedEntity<FuelType.RelationName>
	{
		public FuelType() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public FuelType(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public FuelType(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Fuel Type";
		public const string SchemaName = "chpqa_FuelType";
		public const string EntityLogicalName = "chpqa_fueltype";
		public const int EntityTypeCode = 10799;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_fueltypeid")]
		public override System.Guid Id
		{
			get => (FuelTypeId == null || FuelTypeId == Guid.Empty) ? base.Id : FuelTypeId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_fueltypeid");
                    base.Id = value;
                } else {
				    FuelTypeId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_category")]
		public Guid? Category
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_category");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_category"))
				    value = (EntityReference) backupAttributeCollection["chpqa_category"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_category", new EntityReference("chpqa_fuelcategory", value.Value));
                else
	                SetAttributeValue("chpqa_category", value);
			}
		}

        public string CategoryName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_category");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_category"))
				    value = (EntityReference) backupAttributeCollection["chpqa_category"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_fuelcategory", "chpqa_fuelcategoryid", "chpqa_category")]
        public IDictionary<int, string> CategoryLabels { get; set; }

        /// <summary>
        ///  
		/// 'chpqa_FuelTypeId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_fueltypeid")]
		public Guid? FuelTypeId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_fueltypeid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fueltypeid"))
				    value = (Guid?) backupAttributeCollection["chpqa_fueltypeid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_fueltypeid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Fuel Type
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Fuel Type
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty")]
		public MeterReadings[] MeterReadingssOfFuelType
		{
			get => GetRelatedEntities<MeterReadings>("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public MeterReadings[] LoadMeterReadingssOfFuelType(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_meterreadings", LogicalName, "chpqa_fueltype", "chpqa_fueltypeid", "chpqa_fueltypeid", "chpqa_fueltypeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<MeterReadings>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty"), alreadyTracked); } catch { }
			    });
			if (MeterReadingssOfFuelType == null || MeterReadingssOfFuelType.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public MeterReadings[] LoadMeterReadingssOfFuelType(IOrganizationService service, params string[] attributes)
		{
			return LoadMeterReadingssOfFuelType(service, -1, -1, null, false, attributes);
		}

		public MeterReadings[] LoadMeterReadingssOfFuelType(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadMeterReadingssOfFuelType(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public MeterReadings[] LoadMeterReadingssOfFuelType(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			MeterReadings[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_meterreadings", LogicalName, "chpqa_fueltype", "chpqa_fueltypeid", "chpqa_fueltypeid", "chpqa_fueltypeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<MeterReadings>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<MeterReadings>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (MeterReadingssOfFuelType == null) { MeterReadingssOfFuelType = resultArray; return; }
					MeterReadingssOfFuelType = MeterReadingssOfFuelType.Union(resultArray).Distinct<MeterReadings>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_fueltype_Category_chpqa_fuelcategor'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor"), AttributeLogicalName("chpqa_category")]
		public FuelCategory FuelCategoryAsCategory
		{
			get => GetRelatedEntity<FuelCategory>("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<FuelCategory>("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public FuelCategory LoadFuelCategoryAsCategory(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_fuelcategory", LogicalName, "chpqa_fuelcategoryid", "chpqa_category", "chpqa_fueltypeid", "chpqa_fueltypeid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_fueltype_Category_chpqa_fuelcategor"), alreadyTracked); } catch { }
			if (FuelCategoryAsCategory == null || FuelCategoryAsCategory.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<FuelCategory>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public FuelCategory LoadFuelCategoryAsCategory(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			FuelCategory result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_fuelcategory", LogicalName, "chpqa_fuelcategoryid", "chpqa_category", "chpqa_fueltypeid", "chpqa_fueltypeid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					FuelCategoryAsCategory = result = (resultTemp == null ? null : resultTemp.ToEntity<FuelCategory>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName MeterReadingssOfFuelType = new RelationName("MeterReadingssOfFuelType");
			public static RelationName FuelCategoryAsCategory = new RelationName("FuelCategoryAsCategory");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["MeterReadingssOfFuelType"] = new object[] { "MeterReadingssOfFuelType", "chpqa_meterreadings", "chpqa_fueltype", "chpqa_fueltype", "chpqa_fueltypeid", "chpqa_fueltypeid", "chpqa_fueltypeid", "chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty", typeof (MeterReadings[]) };
			relationProperties["FuelCategoryAsCategory"] = new object[] { "FuelCategoryAsCategory", "chpqa_fuelcategory", "chpqa_fueltype", "chpqa_fuelcategoryid", "chpqa_category", "chpqa_fueltypeid", "chpqa_fueltypeid", "chpqa_chpqa_fueltype_Category_chpqa_fuelcategor", typeof (FuelCategory) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public FuelType(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_fueltypeid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string Category = "chpqa_category";
			public const string FuelTypeId = "chpqa_fueltypeid";
			public const string Name = "chpqa_name";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string Category = "chpqa_Category";
				public const string FuelTypeId = "chpqa_FuelTypeId";
				public const string Name = "chpqa_Name";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> Category { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Category"},
					};

				public static IDictionary<int, string> FuelTypeId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel Type"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string MeterReadingssOfFuelType = "chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty";
			}
			
			public static class NToOne
			{
				public const string FuelCategoryAsCategory = "chpqa_chpqa_fueltype_Category_chpqa_fuelcategor";

				public static class Lookups
				{
					public const string FuelCategoryAsCategory = "chpqa_category";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Manufacturer

	/// <summary>
	/// 'chpqa_Manufacturer'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_manufacturer")]
	public partial class Manufacturer : GeneratedEntity<Manufacturer.RelationName>
	{
		public Manufacturer() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Manufacturer(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Manufacturer(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Manufacturer";
		public const string SchemaName = "chpqa_Manufacturer";
		public const string EntityLogicalName = "chpqa_manufacturer";
		public const int EntityTypeCode = 10613;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_manufacturerid")]
		public override System.Guid Id
		{
			get => (ManufacturerId == null || ManufacturerId == Guid.Empty) ? base.Id : ManufacturerId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_manufacturerid");
                    base.Id = value;
                } else {
				    ManufacturerId = value;
                }
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_ManufacturerId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_manufacturerid")]
		public Guid? ManufacturerId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_manufacturerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturerid"))
				    value = (Guid?) backupAttributeCollection["chpqa_manufacturerid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_manufacturerid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Manufacturer
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Manufacturer
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu")]
		public Boiler[] BoilersOfManufacturer
		{
			get => GetRelatedEntities<Boiler>("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Boiler[] LoadBoilersOfManufacturer(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_boiler", LogicalName, "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Boiler>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu"), alreadyTracked); } catch { }
			    });
			if (BoilersOfManufacturer == null || BoilersOfManufacturer.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Boiler[] LoadBoilersOfManufacturer(IOrganizationService service, params string[] attributes)
		{
			return LoadBoilersOfManufacturer(service, -1, -1, null, false, attributes);
		}

		public Boiler[] LoadBoilersOfManufacturer(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadBoilersOfManufacturer(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Boiler[] LoadBoilersOfManufacturer(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Boiler[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_boiler", LogicalName, "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (BoilersOfManufacturer == null) { BoilersOfManufacturer = resultArray; return; }
					BoilersOfManufacturer = BoilersOfManufacturer.Union(resultArray).Distinct<Boiler>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_model_Manufacturer_chpqa_manufactur'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_model_Manufacturer_chpqa_manufactur")]
		public Model[] ModelsOfManufacturer
		{
			get => GetRelatedEntities<Model>("chpqa_chpqa_model_Manufacturer_chpqa_manufactur", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_model_Manufacturer_chpqa_manufactur", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Model[] LoadModelsOfManufacturer(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_model", LogicalName, "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Model>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_model_Manufacturer_chpqa_manufactur"), alreadyTracked); } catch { }
			    });
			if (ModelsOfManufacturer == null || ModelsOfManufacturer.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Model[] LoadModelsOfManufacturer(IOrganizationService service, params string[] attributes)
		{
			return LoadModelsOfManufacturer(service, -1, -1, null, false, attributes);
		}

		public Model[] LoadModelsOfManufacturer(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadModelsOfManufacturer(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Model[] LoadModelsOfManufacturer(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Model[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_model", LogicalName, "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Model>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Model>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (ModelsOfManufacturer == null) { ModelsOfManufacturer = resultArray; return; }
					ModelsOfManufacturer = ModelsOfManufacturer.Union(resultArray).Distinct<Model>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_primemover_Manufacturer_chpqa_manuf'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf")]
		public PrimeMover[] PrimeMoversOfManufacturer
		{
			get => GetRelatedEntities<PrimeMover>("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfManufacturer(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemover", LogicalName, "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<PrimeMover>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf"), alreadyTracked); } catch { }
			    });
			if (PrimeMoversOfManufacturer == null || PrimeMoversOfManufacturer.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public PrimeMover[] LoadPrimeMoversOfManufacturer(IOrganizationService service, params string[] attributes)
		{
			return LoadPrimeMoversOfManufacturer(service, -1, -1, null, false, attributes);
		}

		public PrimeMover[] LoadPrimeMoversOfManufacturer(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadPrimeMoversOfManufacturer(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfManufacturer(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			PrimeMover[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemover", LogicalName, "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (PrimeMoversOfManufacturer == null) { PrimeMoversOfManufacturer = resultArray; return; }
					PrimeMoversOfManufacturer = PrimeMoversOfManufacturer.Union(resultArray).Distinct<PrimeMover>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		public static class RelationNames {
			public static RelationName BoilersOfManufacturer = new RelationName("BoilersOfManufacturer");
			public static RelationName ModelsOfManufacturer = new RelationName("ModelsOfManufacturer");
			public static RelationName PrimeMoversOfManufacturer = new RelationName("PrimeMoversOfManufacturer");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["BoilersOfManufacturer"] = new object[] { "BoilersOfManufacturer", "chpqa_boiler", "chpqa_manufacturer", "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu", typeof (Boiler[]) };
			relationProperties["ModelsOfManufacturer"] = new object[] { "ModelsOfManufacturer", "chpqa_model", "chpqa_manufacturer", "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_chpqa_model_Manufacturer_chpqa_manufactur", typeof (Model[]) };
			relationProperties["PrimeMoversOfManufacturer"] = new object[] { "PrimeMoversOfManufacturer", "chpqa_primemover", "chpqa_manufacturer", "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_manufacturerid", "chpqa_chpqa_primemover_Manufacturer_chpqa_manuf", typeof (PrimeMover[]) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Manufacturer(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_manufacturerid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string ManufacturerId = "chpqa_manufacturerid";
			public const string Name = "chpqa_name";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string ManufacturerId = "chpqa_ManufacturerId";
				public const string Name = "chpqa_Name";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> ManufacturerId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Manufacturer"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string BoilersOfManufacturer = "chpqa_chpqa_boiler_Manufacturer_chpqa_manufactu";
				public const string ModelsOfManufacturer = "chpqa_chpqa_model_Manufacturer_chpqa_manufactur";
				public const string PrimeMoversOfManufacturer = "chpqa_chpqa_primemover_Manufacturer_chpqa_manuf";
			}
			
			public static class NToOne
			{

				public static class Lookups
				{
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Meter

	/// <summary>
	/// 'chpqa_Meter'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_meter")]
	public partial class Meter : GeneratedEntity<Meter.RelationName>
	{
		public Meter() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Meter(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Meter(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Meter";
		public const string SchemaName = "chpqa_Meter";
		public const string EntityLogicalName = "chpqa_meter";
		public const int EntityTypeCode = 10796;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_meterid")]
		public override System.Guid Id
		{
			get => (MeterId == null || MeterId == Guid.Empty) ? base.Id : MeterId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_meterid");
                    base.Id = value;
                } else {
				    MeterId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_diagramreferencenumber"), Required, MaxLength(100), StringLength(100)]
		public string DiagramReferenceNumber
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_diagramreferencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_diagramreferencenumber"))
				    value = (string) backupAttributeCollection["chpqa_diagramreferencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_diagramreferencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_MeterId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_meterid")]
		public Guid? MeterId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_meterid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_meterid"))
				    value = (Guid?) backupAttributeCollection["chpqa_meterid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_meterid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_meterpointreference"), MaxLength(100), StringLength(100)]
		public string MeterPointReference
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_meterpointreference");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_meterpointreference"))
				    value = (string) backupAttributeCollection["chpqa_meterpointreference"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_meterpointreference", value);
			}
		}

		[AttributeLogicalName("chpqa_metertype"), Required]
		public GlobalEnums.MeterType? MeterType
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_metertype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_metertype"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_metertype"];
				return (GlobalEnums.MeterType?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_metertype", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_metertype", value);
			}
		}

        public IDictionary<int, string> MeterTypeLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_metertype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_metertype"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_metertype"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_metertype", value.Value, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_modeltype"), Required, MaxLength(100), StringLength(100)]
		public string ModelType
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_modeltype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_modeltype"))
				    value = (string) backupAttributeCollection["chpqa_modeltype"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_modeltype", value);
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_outputsrange"), Required, MaxLength(100), StringLength(100)]
		public string OutputsRange
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_outputsrange");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_outputsrange"))
				    value = (string) backupAttributeCollection["chpqa_outputsrange"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_outputsrange", value);
			}
		}

		[AttributeLogicalName("chpqa_outputsunit")]
		public GlobalEnums.MeterOutputUnit? OutputsUnit
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_outputsunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_outputsunit"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_outputsunit"];
				return (GlobalEnums.MeterOutputUnit?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_outputsunit", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_outputsunit", value);
			}
		}

        public IDictionary<int, string> OutputsUnitLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_outputsunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_outputsunit"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_outputsunit"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_outputsunit", value.Value, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_scheme")]
		public Guid? Scheme
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_scheme", new EntityReference("chpqa_scheme", value.Value));
                else
	                SetAttributeValue("chpqa_scheme", value);
			}
		}

        public string SchemeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_ref", "chpqa_scheme", "chpqa_schemeid", "chpqa_scheme")]
        public IDictionary<int, string> SchemeLabels { get; set; }

		[AttributeLogicalName("chpqa_serialnumber"), Required, MaxLength(100), StringLength(100)]
		public string SerialNumber
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_serialnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_serialnumber"))
				    value = (string) backupAttributeCollection["chpqa_serialnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_serialnumber", value);
			}
		}

		[AttributeLogicalName("chpqa_submission")]
		public Guid? Submission
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_submission", new EntityReference("chpqa_submission", value.Value));
                else
	                SetAttributeValue("chpqa_submission", value);
			}
		}

        public string SubmissionName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_submission", "chpqa_submissionid", "chpqa_submission")]
        public IDictionary<int, string> SubmissionLabels { get; set; }

		[AttributeLogicalName("chpqa_tag"), Required, MaxLength(5), StringLength(5)]
		public string Tag
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_tag");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_tag"))
				    value = (string) backupAttributeCollection["chpqa_tag"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_tag", value);
			}
		}

		[AttributeLogicalName("chpqa_uncertainty"), Required, Range(-100,100)]
		public decimal? Uncertainty
		{
			get
			{
				var value = GetAttributeValue<decimal?>("chpqa_uncertainty");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_uncertainty"))
				    value = (decimal?) backupAttributeCollection["chpqa_uncertainty"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_uncertainty", value);
			}
		}

		[AttributeLogicalName("chpqa_yearinstalled"), Required, Range(1990,2200)]
		public int? YearInstalled
		{
			get
			{
				var value = GetAttributeValue<int?>("chpqa_yearinstalled");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_yearinstalled"))
				    value = (int?) backupAttributeCollection["chpqa_yearinstalled"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_yearinstalled", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Meter
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Meter
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// N:1, 'chpqa_Meter_chpqa_Scheme_chpqa_Scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_Meter_chpqa_Scheme_chpqa_Scheme"), AttributeLogicalName("chpqa_scheme")]
		public Scheme SchemeAsScheme
		{
			get => GetRelatedEntity<Scheme>("chpqa_Meter_chpqa_Scheme_chpqa_Scheme", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Scheme>("chpqa_Meter_chpqa_Scheme_chpqa_Scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_meterid", "chpqa_meterid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_Meter_chpqa_Scheme_chpqa_Scheme"), alreadyTracked); } catch { }
			if (SchemeAsScheme == null || SchemeAsScheme.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Scheme>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Scheme result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_meterid", "chpqa_meterid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SchemeAsScheme = result = (resultTemp == null ? null : resultTemp.ToEntity<Scheme>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_Meter_chpqa_Submission_chpqa_Submis'
		/// </summary>
		[RelationshipSchemaName("chpqa_Meter_chpqa_Submission_chpqa_Submis"), AttributeLogicalName("chpqa_submission")]
		public Submission SubmissionAsSubmission
		{
			get => GetRelatedEntity<Submission>("chpqa_Meter_chpqa_Submission_chpqa_Submis", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Submission>("chpqa_Meter_chpqa_Submission_chpqa_Submis", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_meterid", "chpqa_meterid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_Meter_chpqa_Submission_chpqa_Submis"), alreadyTracked); } catch { }
			if (SubmissionAsSubmission == null || SubmissionAsSubmission.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Submission>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Submission result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_meterid", "chpqa_meterid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SubmissionAsSubmission = result = (resultTemp == null ? null : resultTemp.ToEntity<Submission>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName SchemeAsScheme = new RelationName("SchemeAsScheme");
			public static RelationName SubmissionAsSubmission = new RelationName("SubmissionAsSubmission");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["SchemeAsScheme"] = new object[] { "SchemeAsScheme", "chpqa_scheme", "chpqa_meter", "chpqa_schemeid", "chpqa_scheme", "chpqa_meterid", "chpqa_meterid", "chpqa_Meter_chpqa_Scheme_chpqa_Scheme", typeof (Scheme) };
			relationProperties["SubmissionAsSubmission"] = new object[] { "SubmissionAsSubmission", "chpqa_submission", "chpqa_meter", "chpqa_submissionid", "chpqa_submission", "chpqa_meterid", "chpqa_meterid", "chpqa_Meter_chpqa_Submission_chpqa_Submis", typeof (Submission) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Meter(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_meterid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string MeterType = "chpqa_metertype";
				public const string OutputsUnit = "chpqa_outputsunit";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> MeterType { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{303150000, "Fuel"},
								{303150001, "Electricity"},
								{303150002, "Heat"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> OutputsUnit { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "KWh"},
								{709570001, "MWh"},
								{303150001, "Cubic meters"},
								{303150002, "Litres"},
								{303150003, "Kg"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string DiagramReferenceNumber = "chpqa_diagramreferencenumber";
			public const string MeterId = "chpqa_meterid";
			public const string MeterPointReference = "chpqa_meterpointreference";
			public const string MeterType = "chpqa_metertype";
			public const string ModelType = "chpqa_modeltype";
			public const string Name = "chpqa_name";
			public const string OutputsRange = "chpqa_outputsrange";
			public const string OutputsUnit = "chpqa_outputsunit";
			public const string Scheme = "chpqa_scheme";
			public const string SerialNumber = "chpqa_serialnumber";
			public const string Submission = "chpqa_submission";
			public const string Tag = "chpqa_tag";
			public const string Uncertainty = "chpqa_uncertainty";
			public const string YearInstalled = "chpqa_yearinstalled";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string DiagramReferenceNumber = "chpqa_DiagramReferenceNumber";
				public const string MeterId = "chpqa_MeterId";
				public const string MeterPointReference = "chpqa_MeterPointReference";
				public const string MeterType = "chpqa_MeterType";
				public const string ModelType = "chpqa_ModelType";
				public const string Name = "chpqa_Name";
				public const string OutputsRange = "chpqa_OutputsRange";
				public const string OutputsUnit = "chpqa_OutputsUnit";
				public const string Scheme = "chpqa_Scheme";
				public const string SerialNumber = "chpqa_SerialNumber";
				public const string Submission = "chpqa_Submission";
				public const string Tag = "chpqa_Tag";
				public const string Uncertainty = "chpqa_Uncertainty";
				public const string YearInstalled = "chpqa_YearInstalled";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> DiagramReferenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Diagram Reference Number"},
					};

				public static IDictionary<int, string> MeterId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Meter"},
					};

				public static IDictionary<int, string> MeterPointReference { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Meter Point Reference"},
					};

				public static IDictionary<int, string> MeterType { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Meter Type"},
					};

				public static IDictionary<int, string> ModelType { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Model Type"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> OutputsRange { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Outputs Range"},
					};

				public static IDictionary<int, string> OutputsUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Outputs Unit"},
					};

				public static IDictionary<int, string> Scheme { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme"},
					};

				public static IDictionary<int, string> SerialNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Serial Number"},
					};

				public static IDictionary<int, string> Submission { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Submission"},
					};

				public static IDictionary<int, string> Tag { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Tag"},
					};

				public static IDictionary<int, string> Uncertainty { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Uncertainty"},
					};

				public static IDictionary<int, string> YearInstalled { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Year Installed"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
			}
			
			public static class NToOne
			{
				public const string SchemeAsScheme = "chpqa_Meter_chpqa_Scheme_chpqa_Scheme";
				public const string SubmissionAsSubmission = "chpqa_Meter_chpqa_Submission_chpqa_Submis";

				public static class Lookups
				{
					public const string SchemeAsScheme = "chpqa_scheme";
					public const string SubmissionAsSubmission = "chpqa_submission";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region MeterReadings

	/// <summary>
	/// 'chpqa_MeterReadings'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_meterreadings")]
	public partial class MeterReadings : GeneratedEntity<MeterReadings.RelationName>
	{
		public MeterReadings() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public MeterReadings(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public MeterReadings(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Meter Readings";
		public const string SchemaName = "chpqa_MeterReadings";
		public const string EntityLogicalName = "chpqa_meterreadings";
		public const int EntityTypeCode = 10797;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_meterreadingsid")]
		public override System.Guid Id
		{
			get => (MeterReadingsId == null || MeterReadingsId == Guid.Empty) ? base.Id : MeterReadingsId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_meterreadingsid");
                    base.Id = value;
                } else {
				    MeterReadingsId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_fuelcategory")]
		public Guid? FuelCategory
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_fuelcategory");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelcategory"))
				    value = (EntityReference) backupAttributeCollection["chpqa_fuelcategory"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_fuelcategory", new EntityReference("chpqa_fuelcategory", value.Value));
                else
	                SetAttributeValue("chpqa_fuelcategory", value);
			}
		}

        public string FuelCategoryName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_fuelcategory");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelcategory"))
				    value = (EntityReference) backupAttributeCollection["chpqa_fuelcategory"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_fuelcategory", "chpqa_fuelcategoryid", "chpqa_fuelcategory")]
        public IDictionary<int, string> FuelCategoryLabels { get; set; }

		[AttributeLogicalName("chpqa_fueltype")]
		public Guid? FuelType
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_fueltype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fueltype"))
				    value = (EntityReference) backupAttributeCollection["chpqa_fueltype"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_fueltype", new EntityReference("chpqa_fueltype", value.Value));
                else
	                SetAttributeValue("chpqa_fueltype", value);
			}
		}

        public string FuelTypeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_fueltype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fueltype"))
				    value = (EntityReference) backupAttributeCollection["chpqa_fueltype"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_fueltype", "chpqa_fueltypeid", "chpqa_fueltype")]
        public IDictionary<int, string> FuelTypeLabels { get; set; }

		[AttributeLogicalName("chpqa_haveusedcalculations")]
		public bool? HaveUsedCalculations
		{
			get
			{
				var value = GetAttributeValue<bool?>("chpqa_haveusedcalculations");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_haveusedcalculations"))
				    value = (bool?) backupAttributeCollection["chpqa_haveusedcalculations"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_haveusedcalculations", value);
			}
		}

        public IDictionary<int, string> HaveUsedCalculationsLabels
        {
		    get
		    {
                var value = GetAttributeValue<bool?>("chpqa_haveusedcalculations");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_haveusedcalculations"))
				    value = (bool?) backupAttributeCollection["chpqa_haveusedcalculations"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_haveusedcalculations", (bool) value ? 1 : 0, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_heattype")]
		public GlobalEnums.HeatType? HeatType
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_heattype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_heattype"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_heattype"];
				return (GlobalEnums.HeatType?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_heattype", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_heattype", value);
			}
		}

        public IDictionary<int, string> HeatTypeLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_heattype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_heattype"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_heattype"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_heattype", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'chpqa_MeterReadingsId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_meterreadingsid")]
		public Guid? MeterReadingsId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_meterreadingsid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_meterreadingsid"))
				    value = (Guid?) backupAttributeCollection["chpqa_meterreadingsid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_meterreadingsid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_poweroutputtype")]
		public GlobalEnums.PowerOutputType? PowerOutputType
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_poweroutputtype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_poweroutputtype"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_poweroutputtype"];
				return (GlobalEnums.PowerOutputType?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_poweroutputtype", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_poweroutputtype", value);
			}
		}

        public IDictionary<int, string> PowerOutputTypeLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_poweroutputtype");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_poweroutputtype"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_poweroutputtype"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_poweroutputtype", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Meter Readings
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Meter Readings
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_meterreadingvalue_MeterReading_chpq'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_meterreadingvalue_MeterReading_chpq")]
		public MeterReadingValue[] MeterReadingValuesOfMeterReading
		{
			get => GetRelatedEntities<MeterReadingValue>("chpqa_chpqa_meterreadingvalue_MeterReading_chpq", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_meterreadingvalue_MeterReading_chpq", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public MeterReadingValue[] LoadMeterReadingValuesOfMeterReading(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_meterreadingvalue", LogicalName, "chpqa_meterreading", "chpqa_meterreadingsid", "chpqa_meterreadingsid", "chpqa_meterreadingsid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<MeterReadingValue>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_meterreadingvalue_MeterReading_chpq"), alreadyTracked); } catch { }
			    });
			if (MeterReadingValuesOfMeterReading == null || MeterReadingValuesOfMeterReading.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public MeterReadingValue[] LoadMeterReadingValuesOfMeterReading(IOrganizationService service, params string[] attributes)
		{
			return LoadMeterReadingValuesOfMeterReading(service, -1, -1, null, false, attributes);
		}

		public MeterReadingValue[] LoadMeterReadingValuesOfMeterReading(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadMeterReadingValuesOfMeterReading(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public MeterReadingValue[] LoadMeterReadingValuesOfMeterReading(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			MeterReadingValue[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_meterreadingvalue", LogicalName, "chpqa_meterreading", "chpqa_meterreadingsid", "chpqa_meterreadingsid", "chpqa_meterreadingsid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<MeterReadingValue>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<MeterReadingValue>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (MeterReadingValuesOfMeterReading == null) { MeterReadingValuesOfMeterReading = resultArray; return; }
					MeterReadingValuesOfMeterReading = MeterReadingValuesOfMeterReading.Union(resultArray).Distinct<MeterReadingValue>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu"), AttributeLogicalName("chpqa_fuelcategory")]
		public FuelCategory FuelCategoryAsFuelCategory
		{
			get => GetRelatedEntity<FuelCategory>("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<FuelCategory>("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public FuelCategory LoadFuelCategoryAsFuelCategory(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_fuelcategory", LogicalName, "chpqa_fuelcategoryid", "chpqa_fuelcategory", "chpqa_meterreadingsid", "chpqa_meterreadingsid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu"), alreadyTracked); } catch { }
			if (FuelCategoryAsFuelCategory == null || FuelCategoryAsFuelCategory.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<FuelCategory>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public FuelCategory LoadFuelCategoryAsFuelCategory(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			FuelCategory result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_fuelcategory", LogicalName, "chpqa_fuelcategoryid", "chpqa_fuelcategory", "chpqa_meterreadingsid", "chpqa_meterreadingsid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					FuelCategoryAsFuelCategory = result = (resultTemp == null ? null : resultTemp.ToEntity<FuelCategory>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty"), AttributeLogicalName("chpqa_fueltype")]
		public FuelType FuelTypeAsFuelType
		{
			get => GetRelatedEntity<FuelType>("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<FuelType>("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public FuelType LoadFuelTypeAsFuelType(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_fueltype", LogicalName, "chpqa_fueltypeid", "chpqa_fueltype", "chpqa_meterreadingsid", "chpqa_meterreadingsid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty"), alreadyTracked); } catch { }
			if (FuelTypeAsFuelType == null || FuelTypeAsFuelType.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<FuelType>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public FuelType LoadFuelTypeAsFuelType(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			FuelType result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_fueltype", LogicalName, "chpqa_fueltypeid", "chpqa_fueltype", "chpqa_meterreadingsid", "chpqa_meterreadingsid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					FuelTypeAsFuelType = result = (resultTemp == null ? null : resultTemp.ToEntity<FuelType>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName MeterReadingValuesOfMeterReading = new RelationName("MeterReadingValuesOfMeterReading");
			public static RelationName FuelCategoryAsFuelCategory = new RelationName("FuelCategoryAsFuelCategory");
			public static RelationName FuelTypeAsFuelType = new RelationName("FuelTypeAsFuelType");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["MeterReadingValuesOfMeterReading"] = new object[] { "MeterReadingValuesOfMeterReading", "chpqa_meterreadingvalue", "chpqa_meterreadings", "chpqa_meterreading", "chpqa_meterreadingsid", "chpqa_meterreadingsid", "chpqa_meterreadingsid", "chpqa_chpqa_meterreadingvalue_MeterReading_chpq", typeof (MeterReadingValue[]) };
			relationProperties["FuelCategoryAsFuelCategory"] = new object[] { "FuelCategoryAsFuelCategory", "chpqa_fuelcategory", "chpqa_meterreadings", "chpqa_fuelcategoryid", "chpqa_fuelcategory", "chpqa_meterreadingsid", "chpqa_meterreadingsid", "chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu", typeof (FuelCategory) };
			relationProperties["FuelTypeAsFuelType"] = new object[] { "FuelTypeAsFuelType", "chpqa_fueltype", "chpqa_meterreadings", "chpqa_fueltypeid", "chpqa_fueltype", "chpqa_meterreadingsid", "chpqa_meterreadingsid", "chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty", typeof (FuelType) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public MeterReadings(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_meterreadingsid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum HaveUsedCalculationsEnum
		{
			Yes = 1,
			No = 0,
		}
	
		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string HaveUsedCalculations = "chpqa_haveusedcalculations";
				public const string HeatType = "chpqa_heattype";
				public const string PowerOutputType = "chpqa_poweroutputtype";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> HaveUsedCalculations { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Yes"},
								{0, "No"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> HeatType { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "Supplied Site"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> PowerOutputType { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "Generated"},
								{709570001, "Exported"},
								{709570002, "Imported"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string FuelCategory = "chpqa_fuelcategory";
			public const string FuelType = "chpqa_fueltype";
			public const string HaveUsedCalculations = "chpqa_haveusedcalculations";
			public const string HeatType = "chpqa_heattype";
			public const string MeterReadingsId = "chpqa_meterreadingsid";
			public const string Name = "chpqa_name";
			public const string PowerOutputType = "chpqa_poweroutputtype";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string FuelCategory = "chpqa_FuelCategory";
				public const string FuelType = "chpqa_FuelType";
				public const string HaveUsedCalculations = "chpqa_HaveUsedCalculations";
				public const string HeatType = "chpqa_HeatType";
				public const string MeterReadingsId = "chpqa_MeterReadingsId";
				public const string Name = "chpqa_Name";
				public const string PowerOutputType = "chpqa_PowerOutputType";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> FuelCategory { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel Category"},
					};

				public static IDictionary<int, string> FuelType { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel Type"},
					};

				public static IDictionary<int, string> HaveUsedCalculations { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Have Used Calculations"},
					};

				public static IDictionary<int, string> HeatType { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Heat Type"},
					};

				public static IDictionary<int, string> MeterReadingsId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Meter Readings"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> PowerOutputType { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Power Output Type"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string MeterReadingValuesOfMeterReading = "chpqa_chpqa_meterreadingvalue_MeterReading_chpq";
			}
			
			public static class NToOne
			{
				public const string FuelCategoryAsFuelCategory = "chpqa_chpqa_meterreadings_FuelCategory_chpqa_fu";
				public const string FuelTypeAsFuelType = "chpqa_chpqa_meterreadings_FuelType_chpqa_fuelty";

				public static class Lookups
				{
					public const string FuelCategoryAsFuelCategory = "chpqa_fuelcategory";
					public const string FuelTypeAsFuelType = "chpqa_fueltype";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region MeterReadingValue

	/// <summary>
	/// 'chpqa_MeterReadingValue'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_meterreadingvalue")]
	public partial class MeterReadingValue : GeneratedEntity<MeterReadingValue.RelationName>
	{
		public MeterReadingValue() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public MeterReadingValue(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public MeterReadingValue(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Meter Reading Value";
		public const string SchemaName = "chpqa_MeterReadingValue";
		public const string EntityLogicalName = "chpqa_meterreadingvalue";
		public const int EntityTypeCode = 10800;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_meterreadingvalueid")]
		public override System.Guid Id
		{
			get => (MeterReadingValueId == null || MeterReadingValueId == Guid.Empty) ? base.Id : MeterReadingValueId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_meterreadingvalueid");
                    base.Id = value;
                } else {
				    MeterReadingValueId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_meterreading")]
		public Guid? MeterReading
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_meterreading");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_meterreading"))
				    value = (EntityReference) backupAttributeCollection["chpqa_meterreading"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_meterreading", new EntityReference("chpqa_meterreadings", value.Value));
                else
	                SetAttributeValue("chpqa_meterreading", value);
			}
		}

        public string MeterReadingName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_meterreading");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_meterreading"))
				    value = (EntityReference) backupAttributeCollection["chpqa_meterreading"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_meterreadings", "chpqa_meterreadingsid", "chpqa_meterreading")]
        public IDictionary<int, string> MeterReadingLabels { get; set; }

        /// <summary>
        ///  
		/// 'chpqa_MeterReadingValueId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_meterreadingvalueid")]
		public Guid? MeterReadingValueId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_meterreadingvalueid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_meterreadingvalueid"))
				    value = (Guid?) backupAttributeCollection["chpqa_meterreadingvalueid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_meterreadingvalueid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_month"), Required, Range(0,11)]
		public int? Month
		{
			get
			{
				var value = GetAttributeValue<int?>("chpqa_month");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_month"))
				    value = (int?) backupAttributeCollection["chpqa_month"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_month", value);
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_value"), Required, Range(-100000000000,100000000000)]
		public decimal? Value
		{
			get
			{
				var value = GetAttributeValue<decimal?>("chpqa_value");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_value"))
				    value = (decimal?) backupAttributeCollection["chpqa_value"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_value", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Meter Reading Value
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Meter Reading Value
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// N:1, 'chpqa_chpqa_meterreadingvalue_MeterReading_chpq'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_meterreadingvalue_MeterReading_chpq"), AttributeLogicalName("chpqa_meterreading")]
		public MeterReadings MeterReadingsAsMeterReading
		{
			get => GetRelatedEntity<MeterReadings>("chpqa_chpqa_meterreadingvalue_MeterReading_chpq", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<MeterReadings>("chpqa_chpqa_meterreadingvalue_MeterReading_chpq", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public MeterReadings LoadMeterReadingsAsMeterReading(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_meterreadings", LogicalName, "chpqa_meterreadingsid", "chpqa_meterreading", "chpqa_meterreadingvalueid", "chpqa_meterreadingvalueid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_meterreadingvalue_MeterReading_chpq"), alreadyTracked); } catch { }
			if (MeterReadingsAsMeterReading == null || MeterReadingsAsMeterReading.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<MeterReadings>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public MeterReadings LoadMeterReadingsAsMeterReading(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			MeterReadings result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_meterreadings", LogicalName, "chpqa_meterreadingsid", "chpqa_meterreading", "chpqa_meterreadingvalueid", "chpqa_meterreadingvalueid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					MeterReadingsAsMeterReading = result = (resultTemp == null ? null : resultTemp.ToEntity<MeterReadings>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName MeterReadingsAsMeterReading = new RelationName("MeterReadingsAsMeterReading");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["MeterReadingsAsMeterReading"] = new object[] { "MeterReadingsAsMeterReading", "chpqa_meterreadings", "chpqa_meterreadingvalue", "chpqa_meterreadingsid", "chpqa_meterreading", "chpqa_meterreadingvalueid", "chpqa_meterreadingvalueid", "chpqa_chpqa_meterreadingvalue_MeterReading_chpq", typeof (MeterReadings) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public MeterReadingValue(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_meterreadingvalueid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string MeterReading = "chpqa_meterreading";
			public const string MeterReadingValueId = "chpqa_meterreadingvalueid";
			public const string Month = "chpqa_month";
			public const string Name = "chpqa_name";
			public const string Value = "chpqa_value";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string MeterReading = "chpqa_MeterReading";
				public const string MeterReadingValueId = "chpqa_MeterReadingValueId";
				public const string Month = "chpqa_Month";
				public const string Name = "chpqa_Name";
				public const string Value = "chpqa_Value";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> MeterReading { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Meter Reading"},
					};

				public static IDictionary<int, string> MeterReadingValueId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Meter Reading Value"},
					};

				public static IDictionary<int, string> Month { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Month"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> Value { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Value"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
			}
			
			public static class NToOne
			{
				public const string MeterReadingsAsMeterReading = "chpqa_chpqa_meterreadingvalue_MeterReading_chpq";

				public static class Lookups
				{
					public const string MeterReadingsAsMeterReading = "chpqa_meterreading";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Model

	/// <summary>
	/// 'chpqa_Model'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_model")]
	public partial class Model : GeneratedEntity<Model.RelationName>
	{
		public Model() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Model(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Model(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Model";
		public const string SchemaName = "chpqa_Model";
		public const string EntityLogicalName = "chpqa_model";
		public const int EntityTypeCode = 10602;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_modelid")]
		public override System.Guid Id
		{
			get => (ModelId == null || ModelId == Guid.Empty) ? base.Id : ModelId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_modelid");
                    base.Id = value;
                } else {
				    ModelId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_manufacturer")]
		public Guid? Manufacturer
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_manufacturer");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturer"))
				    value = (EntityReference) backupAttributeCollection["chpqa_manufacturer"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_manufacturer", new EntityReference("chpqa_manufacturer", value.Value));
                else
	                SetAttributeValue("chpqa_manufacturer", value);
			}
		}

        public string ManufacturerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_manufacturer");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturer"))
				    value = (EntityReference) backupAttributeCollection["chpqa_manufacturer"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturer")]
        public IDictionary<int, string> ManufacturerLabels { get; set; }

        /// <summary>
        ///  
		/// 'chpqa_ModelId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_modelid")]
		public Guid? ModelId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_modelid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_modelid"))
				    value = (Guid?) backupAttributeCollection["chpqa_modelid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_modelid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Model
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Model
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_boiler_Model_chpqa_model'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Model_chpqa_model")]
		public Boiler[] BoilersOfModel
		{
			get => GetRelatedEntities<Boiler>("chpqa_chpqa_boiler_Model_chpqa_model", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_boiler_Model_chpqa_model", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Boiler[] LoadBoilersOfModel(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_boiler", LogicalName, "chpqa_model", "chpqa_modelid", "chpqa_modelid", "chpqa_modelid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Boiler>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Model_chpqa_model"), alreadyTracked); } catch { }
			    });
			if (BoilersOfModel == null || BoilersOfModel.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Boiler[] LoadBoilersOfModel(IOrganizationService service, params string[] attributes)
		{
			return LoadBoilersOfModel(service, -1, -1, null, false, attributes);
		}

		public Boiler[] LoadBoilersOfModel(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadBoilersOfModel(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Boiler[] LoadBoilersOfModel(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Boiler[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_boiler", LogicalName, "chpqa_model", "chpqa_modelid", "chpqa_modelid", "chpqa_modelid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (BoilersOfModel == null) { BoilersOfModel = resultArray; return; }
					BoilersOfModel = BoilersOfModel.Union(resultArray).Distinct<Boiler>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_primemover_Model_chpqa_model'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Model_chpqa_model")]
		public PrimeMover[] PrimeMoversOfModel
		{
			get => GetRelatedEntities<PrimeMover>("chpqa_chpqa_primemover_Model_chpqa_model", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_primemover_Model_chpqa_model", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfModel(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemover", LogicalName, "chpqa_model", "chpqa_modelid", "chpqa_modelid", "chpqa_modelid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<PrimeMover>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Model_chpqa_model"), alreadyTracked); } catch { }
			    });
			if (PrimeMoversOfModel == null || PrimeMoversOfModel.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public PrimeMover[] LoadPrimeMoversOfModel(IOrganizationService service, params string[] attributes)
		{
			return LoadPrimeMoversOfModel(service, -1, -1, null, false, attributes);
		}

		public PrimeMover[] LoadPrimeMoversOfModel(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadPrimeMoversOfModel(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfModel(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			PrimeMover[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemover", LogicalName, "chpqa_model", "chpqa_modelid", "chpqa_modelid", "chpqa_modelid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (PrimeMoversOfModel == null) { PrimeMoversOfModel = resultArray; return; }
					PrimeMoversOfModel = PrimeMoversOfModel.Union(resultArray).Distinct<PrimeMover>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_model_Manufacturer_chpqa_manufactur'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_model_Manufacturer_chpqa_manufactur"), AttributeLogicalName("chpqa_manufacturer")]
		public Manufacturer ManufacturerAsManufacturer
		{
			get => GetRelatedEntity<Manufacturer>("chpqa_chpqa_model_Manufacturer_chpqa_manufactur", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Manufacturer>("chpqa_chpqa_model_Manufacturer_chpqa_manufactur", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Manufacturer LoadManufacturerAsManufacturer(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_manufacturer", LogicalName, "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_modelid", "chpqa_modelid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_model_Manufacturer_chpqa_manufactur"), alreadyTracked); } catch { }
			if (ManufacturerAsManufacturer == null || ManufacturerAsManufacturer.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Manufacturer>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Manufacturer LoadManufacturerAsManufacturer(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Manufacturer result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_manufacturer", LogicalName, "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_modelid", "chpqa_modelid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					ManufacturerAsManufacturer = result = (resultTemp == null ? null : resultTemp.ToEntity<Manufacturer>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName BoilersOfModel = new RelationName("BoilersOfModel");
			public static RelationName PrimeMoversOfModel = new RelationName("PrimeMoversOfModel");
			public static RelationName ManufacturerAsManufacturer = new RelationName("ManufacturerAsManufacturer");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["BoilersOfModel"] = new object[] { "BoilersOfModel", "chpqa_boiler", "chpqa_model", "chpqa_model", "chpqa_modelid", "chpqa_modelid", "chpqa_modelid", "chpqa_chpqa_boiler_Model_chpqa_model", typeof (Boiler[]) };
			relationProperties["PrimeMoversOfModel"] = new object[] { "PrimeMoversOfModel", "chpqa_primemover", "chpqa_model", "chpqa_model", "chpqa_modelid", "chpqa_modelid", "chpqa_modelid", "chpqa_chpqa_primemover_Model_chpqa_model", typeof (PrimeMover[]) };
			relationProperties["ManufacturerAsManufacturer"] = new object[] { "ManufacturerAsManufacturer", "chpqa_manufacturer", "chpqa_model", "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_modelid", "chpqa_modelid", "chpqa_chpqa_model_Manufacturer_chpqa_manufactur", typeof (Manufacturer) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Model(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_modelid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string Manufacturer = "chpqa_manufacturer";
			public const string ModelId = "chpqa_modelid";
			public const string Name = "chpqa_name";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string Manufacturer = "chpqa_Manufacturer";
				public const string ModelId = "chpqa_ModelId";
				public const string Name = "chpqa_Name";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> Manufacturer { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Manufacturer"},
					};

				public static IDictionary<int, string> ModelId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Model"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string BoilersOfModel = "chpqa_chpqa_boiler_Model_chpqa_model";
				public const string PrimeMoversOfModel = "chpqa_chpqa_primemover_Model_chpqa_model";
			}
			
			public static class NToOne
			{
				public const string ManufacturerAsManufacturer = "chpqa_chpqa_model_Manufacturer_chpqa_manufactur";

				public static class Lookups
				{
					public const string ManufacturerAsManufacturer = "chpqa_manufacturer";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region PrimeMover

	/// <summary>
	/// 'chpqa_PrimeMover'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_primemover")]
	public partial class PrimeMover : GeneratedEntity<PrimeMover.RelationName>
	{
		public PrimeMover() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public PrimeMover(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public PrimeMover(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Prime Mover";
		public const string SchemaName = "chpqa_PrimeMover";
		public const string EntityLogicalName = "chpqa_primemover";
		public const int EntityTypeCode = 10776;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_primemoverid")]
		public override System.Guid Id
		{
			get => (PrimeMoverId == null || PrimeMoverId == Guid.Empty) ? base.Id : PrimeMoverId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_primemoverid");
                    base.Id = value;
                } else {
				    PrimeMoverId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_fuel"), Required]
		public Guid? Fuel
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_fuel");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuel"))
				    value = (EntityReference) backupAttributeCollection["chpqa_fuel"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_fuel", new EntityReference("chpqa_fuel", value.Value));
                else
	                SetAttributeValue("chpqa_fuel", value);
			}
		}

        public string FuelName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_fuel");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuel"))
				    value = (EntityReference) backupAttributeCollection["chpqa_fuel"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_fuel", "chpqa_fuelid", "chpqa_fuel")]
        public IDictionary<int, string> FuelLabels { get; set; }

		[AttributeLogicalName("chpqa_manufacturer"), Required]
		public Guid? Manufacturer
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_manufacturer");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturer"))
				    value = (EntityReference) backupAttributeCollection["chpqa_manufacturer"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_manufacturer", new EntityReference("chpqa_manufacturer", value.Value));
                else
	                SetAttributeValue("chpqa_manufacturer", value);
			}
		}

        public string ManufacturerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_manufacturer");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_manufacturer"))
				    value = (EntityReference) backupAttributeCollection["chpqa_manufacturer"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_manufacturer", "chpqa_manufacturerid", "chpqa_manufacturer")]
        public IDictionary<int, string> ManufacturerLabels { get; set; }

		[AttributeLogicalName("chpqa_maximumratedheat"), Required, MaxLength(100), StringLength(100)]
		public string MaximumRatedHeat
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_maximumratedheat");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_maximumratedheat"))
				    value = (string) backupAttributeCollection["chpqa_maximumratedheat"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_maximumratedheat", value);
			}
		}

		[AttributeLogicalName("chpqa_maximumratedpower"), Required, MaxLength(100), StringLength(100)]
		public string MaximumRatedPower
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_maximumratedpower");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_maximumratedpower"))
				    value = (string) backupAttributeCollection["chpqa_maximumratedpower"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_maximumratedpower", value);
			}
		}

		[AttributeLogicalName("chpqa_model"), Required]
		public Guid? Model
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_model");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_model"))
				    value = (EntityReference) backupAttributeCollection["chpqa_model"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_model", new EntityReference("chpqa_model", value.Value));
                else
	                SetAttributeValue("chpqa_model", value);
			}
		}

        public string ModelName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_model");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_model"))
				    value = (EntityReference) backupAttributeCollection["chpqa_model"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_model", "chpqa_modelid", "chpqa_model")]
        public IDictionary<int, string> ModelLabels { get; set; }

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_PrimeMoverId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_primemoverid")]
		public Guid? PrimeMoverId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_primemoverid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_primemoverid"))
				    value = (Guid?) backupAttributeCollection["chpqa_primemoverid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_primemoverid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_scheme")]
		public Guid? Scheme
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_scheme", new EntityReference("chpqa_scheme", value.Value));
                else
	                SetAttributeValue("chpqa_scheme", value);
			}
		}

        public string SchemeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_ref", "chpqa_scheme", "chpqa_schemeid", "chpqa_scheme")]
        public IDictionary<int, string> SchemeLabels { get; set; }

		[AttributeLogicalName("chpqa_submission")]
		public Guid? Submission
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_submission", new EntityReference("chpqa_submission", value.Value));
                else
	                SetAttributeValue("chpqa_submission", value);
			}
		}

        public string SubmissionName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_submission");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submission"))
				    value = (EntityReference) backupAttributeCollection["chpqa_submission"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_submission", "chpqa_submissionid", "chpqa_submission")]
        public IDictionary<int, string> SubmissionLabels { get; set; }

		[AttributeLogicalName("chpqa_tagnumber"), Required, Range(0,256)]
		public int? TagNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("chpqa_tagnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_tagnumber"))
				    value = (int?) backupAttributeCollection["chpqa_tagnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_tagnumber", value);
			}
		}

		[AttributeLogicalName("chpqa_type"), Required]
		public Guid? Type
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_type");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_type"))
				    value = (EntityReference) backupAttributeCollection["chpqa_type"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_type", new EntityReference("chpqa_primemovertype", value.Value));
                else
	                SetAttributeValue("chpqa_type", value);
			}
		}

        public string TypeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_type");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_type"))
				    value = (EntityReference) backupAttributeCollection["chpqa_type"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_primemovertype", "chpqa_primemovertypeid", "chpqa_type")]
        public IDictionary<int, string> TypeLabels { get; set; }

		[AttributeLogicalName("chpqa_yearcommissioned"), Required, Range(1990,2200)]
		public int? YearCommissioned
		{
			get
			{
				var value = GetAttributeValue<int?>("chpqa_yearcommissioned");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_yearcommissioned"))
				    value = (int?) backupAttributeCollection["chpqa_yearcommissioned"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_yearcommissioned", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Prime Mover
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Prime Mover
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// N:1, 'chpqa_chpqa_primemover_Fuel_chpqa_fuel'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Fuel_chpqa_fuel"), AttributeLogicalName("chpqa_fuel")]
		public Fuel FuelAsFuel
		{
			get => GetRelatedEntity<Fuel>("chpqa_chpqa_primemover_Fuel_chpqa_fuel", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Fuel>("chpqa_chpqa_primemover_Fuel_chpqa_fuel", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Fuel LoadFuelAsFuel(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_fuel", LogicalName, "chpqa_fuelid", "chpqa_fuel", "chpqa_primemoverid", "chpqa_primemoverid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Fuel_chpqa_fuel"), alreadyTracked); } catch { }
			if (FuelAsFuel == null || FuelAsFuel.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Fuel>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Fuel LoadFuelAsFuel(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Fuel result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_fuel", LogicalName, "chpqa_fuelid", "chpqa_fuel", "chpqa_primemoverid", "chpqa_primemoverid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					FuelAsFuel = result = (resultTemp == null ? null : resultTemp.ToEntity<Fuel>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_primemover_Manufacturer_chpqa_manuf'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf"), AttributeLogicalName("chpqa_manufacturer")]
		public Manufacturer ManufacturerAsManufacturer
		{
			get => GetRelatedEntity<Manufacturer>("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Manufacturer>("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Manufacturer LoadManufacturerAsManufacturer(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_manufacturer", LogicalName, "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_primemoverid", "chpqa_primemoverid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Manufacturer_chpqa_manuf"), alreadyTracked); } catch { }
			if (ManufacturerAsManufacturer == null || ManufacturerAsManufacturer.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Manufacturer>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Manufacturer LoadManufacturerAsManufacturer(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Manufacturer result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_manufacturer", LogicalName, "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_primemoverid", "chpqa_primemoverid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					ManufacturerAsManufacturer = result = (resultTemp == null ? null : resultTemp.ToEntity<Manufacturer>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_primemover_Model_chpqa_model'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Model_chpqa_model"), AttributeLogicalName("chpqa_model")]
		public Model ModelAsModel
		{
			get => GetRelatedEntity<Model>("chpqa_chpqa_primemover_Model_chpqa_model", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Model>("chpqa_chpqa_primemover_Model_chpqa_model", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Model LoadModelAsModel(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_model", LogicalName, "chpqa_modelid", "chpqa_model", "chpqa_primemoverid", "chpqa_primemoverid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Model_chpqa_model"), alreadyTracked); } catch { }
			if (ModelAsModel == null || ModelAsModel.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Model>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Model LoadModelAsModel(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Model result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_model", LogicalName, "chpqa_modelid", "chpqa_model", "chpqa_primemoverid", "chpqa_primemoverid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					ModelAsModel = result = (resultTemp == null ? null : resultTemp.ToEntity<Model>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_primemover_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Scheme_chpqa_scheme"), AttributeLogicalName("chpqa_scheme")]
		public Scheme SchemeAsScheme
		{
			get => GetRelatedEntity<Scheme>("chpqa_chpqa_primemover_Scheme_chpqa_scheme", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Scheme>("chpqa_chpqa_primemover_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_primemoverid", "chpqa_primemoverid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			if (SchemeAsScheme == null || SchemeAsScheme.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Scheme>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Scheme result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_primemoverid", "chpqa_primemoverid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SchemeAsScheme = result = (resultTemp == null ? null : resultTemp.ToEntity<Scheme>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_primemover_Type_chpqa_primemovertyp'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Type_chpqa_primemovertyp"), AttributeLogicalName("chpqa_type")]
		public PrimeMoverType PrimeMoverTypeAsType
		{
			get => GetRelatedEntity<PrimeMoverType>("chpqa_chpqa_primemover_Type_chpqa_primemovertyp", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<PrimeMoverType>("chpqa_chpqa_primemover_Type_chpqa_primemovertyp", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMoverType LoadPrimeMoverTypeAsType(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemovertype", LogicalName, "chpqa_primemovertypeid", "chpqa_type", "chpqa_primemoverid", "chpqa_primemoverid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Type_chpqa_primemovertyp"), alreadyTracked); } catch { }
			if (PrimeMoverTypeAsType == null || PrimeMoverTypeAsType.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<PrimeMoverType>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMoverType LoadPrimeMoverTypeAsType(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			PrimeMoverType result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemovertype", LogicalName, "chpqa_primemovertypeid", "chpqa_type", "chpqa_primemoverid", "chpqa_primemoverid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					PrimeMoverTypeAsType = result = (resultTemp == null ? null : resultTemp.ToEntity<PrimeMoverType>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		/// <summary>
		/// N:1, 'chpqa_PrimeMover_chpqa_Submission_chpqa_S'
		/// </summary>
		[RelationshipSchemaName("chpqa_PrimeMover_chpqa_Submission_chpqa_S"), AttributeLogicalName("chpqa_submission")]
		public Submission SubmissionAsSubmission
		{
			get => GetRelatedEntity<Submission>("chpqa_PrimeMover_chpqa_Submission_chpqa_S", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Submission>("chpqa_PrimeMover_chpqa_Submission_chpqa_S", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_primemoverid", "chpqa_primemoverid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_PrimeMover_chpqa_Submission_chpqa_S"), alreadyTracked); } catch { }
			if (SubmissionAsSubmission == null || SubmissionAsSubmission.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Submission>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Submission LoadSubmissionAsSubmission(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Submission result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_submission", LogicalName, "chpqa_submissionid", "chpqa_submission", "chpqa_primemoverid", "chpqa_primemoverid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SubmissionAsSubmission = result = (resultTemp == null ? null : resultTemp.ToEntity<Submission>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName FuelAsFuel = new RelationName("FuelAsFuel");
			public static RelationName ManufacturerAsManufacturer = new RelationName("ManufacturerAsManufacturer");
			public static RelationName ModelAsModel = new RelationName("ModelAsModel");
			public static RelationName SchemeAsScheme = new RelationName("SchemeAsScheme");
			public static RelationName PrimeMoverTypeAsType = new RelationName("PrimeMoverTypeAsType");
			public static RelationName SubmissionAsSubmission = new RelationName("SubmissionAsSubmission");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["FuelAsFuel"] = new object[] { "FuelAsFuel", "chpqa_fuel", "chpqa_primemover", "chpqa_fuelid", "chpqa_fuel", "chpqa_primemoverid", "chpqa_primemoverid", "chpqa_chpqa_primemover_Fuel_chpqa_fuel", typeof (Fuel) };
			relationProperties["ManufacturerAsManufacturer"] = new object[] { "ManufacturerAsManufacturer", "chpqa_manufacturer", "chpqa_primemover", "chpqa_manufacturerid", "chpqa_manufacturer", "chpqa_primemoverid", "chpqa_primemoverid", "chpqa_chpqa_primemover_Manufacturer_chpqa_manuf", typeof (Manufacturer) };
			relationProperties["ModelAsModel"] = new object[] { "ModelAsModel", "chpqa_model", "chpqa_primemover", "chpqa_modelid", "chpqa_model", "chpqa_primemoverid", "chpqa_primemoverid", "chpqa_chpqa_primemover_Model_chpqa_model", typeof (Model) };
			relationProperties["SchemeAsScheme"] = new object[] { "SchemeAsScheme", "chpqa_scheme", "chpqa_primemover", "chpqa_schemeid", "chpqa_scheme", "chpqa_primemoverid", "chpqa_primemoverid", "chpqa_chpqa_primemover_Scheme_chpqa_scheme", typeof (Scheme) };
			relationProperties["PrimeMoverTypeAsType"] = new object[] { "PrimeMoverTypeAsType", "chpqa_primemovertype", "chpqa_primemover", "chpqa_primemovertypeid", "chpqa_type", "chpqa_primemoverid", "chpqa_primemoverid", "chpqa_chpqa_primemover_Type_chpqa_primemovertyp", typeof (PrimeMoverType) };
			relationProperties["SubmissionAsSubmission"] = new object[] { "SubmissionAsSubmission", "chpqa_submission", "chpqa_primemover", "chpqa_submissionid", "chpqa_submission", "chpqa_primemoverid", "chpqa_primemoverid", "chpqa_PrimeMover_chpqa_Submission_chpqa_S", typeof (Submission) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public PrimeMover(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_primemoverid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string Fuel = "chpqa_fuel";
			public const string Manufacturer = "chpqa_manufacturer";
			public const string MaximumRatedHeat = "chpqa_maximumratedheat";
			public const string MaximumRatedPower = "chpqa_maximumratedpower";
			public const string Model = "chpqa_model";
			public const string Name = "chpqa_name";
			public const string PrimeMoverId = "chpqa_primemoverid";
			public const string Scheme = "chpqa_scheme";
			public const string Submission = "chpqa_submission";
			public const string TagNumber = "chpqa_tagnumber";
			public const string Type = "chpqa_type";
			public const string YearCommissioned = "chpqa_yearcommissioned";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string Fuel = "chpqa_Fuel";
				public const string Manufacturer = "chpqa_Manufacturer";
				public const string MaximumRatedHeat = "chpqa_MaximumRatedHeat";
				public const string MaximumRatedPower = "chpqa_MaximumRatedPower";
				public const string Model = "chpqa_Model";
				public const string Name = "chpqa_Name";
				public const string PrimeMoverId = "chpqa_PrimeMoverId";
				public const string Scheme = "chpqa_Scheme";
				public const string Submission = "chpqa_Submission";
				public const string TagNumber = "chpqa_TagNumber";
				public const string Type = "chpqa_Type";
				public const string YearCommissioned = "chpqa_YearCommissioned";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> Fuel { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel"},
					};

				public static IDictionary<int, string> Manufacturer { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Manufacturer"},
					};

				public static IDictionary<int, string> MaximumRatedHeat { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Maximum Rated Heat"},
					};

				public static IDictionary<int, string> MaximumRatedPower { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Maximum Rated Power"},
					};

				public static IDictionary<int, string> Model { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Model"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> PrimeMoverId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Prime Mover"},
					};

				public static IDictionary<int, string> Scheme { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme"},
					};

				public static IDictionary<int, string> Submission { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Submission"},
					};

				public static IDictionary<int, string> TagNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Tag Number"},
					};

				public static IDictionary<int, string> Type { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Type"},
					};

				public static IDictionary<int, string> YearCommissioned { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Year Commissioned"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
			}
			
			public static class NToOne
			{
				public const string FuelAsFuel = "chpqa_chpqa_primemover_Fuel_chpqa_fuel";
				public const string ManufacturerAsManufacturer = "chpqa_chpqa_primemover_Manufacturer_chpqa_manuf";
				public const string ModelAsModel = "chpqa_chpqa_primemover_Model_chpqa_model";
				public const string SchemeAsScheme = "chpqa_chpqa_primemover_Scheme_chpqa_scheme";
				public const string PrimeMoverTypeAsType = "chpqa_chpqa_primemover_Type_chpqa_primemovertyp";
				public const string SubmissionAsSubmission = "chpqa_PrimeMover_chpqa_Submission_chpqa_S";

				public static class Lookups
				{
					public const string FuelAsFuel = "chpqa_fuel";
					public const string ManufacturerAsManufacturer = "chpqa_manufacturer";
					public const string ModelAsModel = "chpqa_model";
					public const string SchemeAsScheme = "chpqa_scheme";
					public const string PrimeMoverTypeAsType = "chpqa_type";
					public const string SubmissionAsSubmission = "chpqa_submission";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region PrimeMoverType

	/// <summary>
	/// 'chpqa_PrimeMoverType'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_primemovertype")]
	public partial class PrimeMoverType : GeneratedEntity<PrimeMoverType.RelationName>
	{
		public PrimeMoverType() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public PrimeMoverType(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public PrimeMoverType(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Prime Mover Type";
		public const string SchemaName = "chpqa_PrimeMoverType";
		public const string EntityLogicalName = "chpqa_primemovertype";
		public const int EntityTypeCode = 10645;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_primemovertypeid")]
		public override System.Guid Id
		{
			get => (PrimeMoverTypeId == null || PrimeMoverTypeId == Guid.Empty) ? base.Id : PrimeMoverTypeId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_primemovertypeid");
                    base.Id = value;
                } else {
				    PrimeMoverTypeId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_description"), Required, MaxLength(100), StringLength(100)]
		public string Description
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_description");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_description"))
				    value = (string) backupAttributeCollection["chpqa_description"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_description", value);
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_PrimeMoverTypeId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_primemovertypeid")]
		public Guid? PrimeMoverTypeId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_primemovertypeid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_primemovertypeid"))
				    value = (Guid?) backupAttributeCollection["chpqa_primemovertypeid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_primemovertypeid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_typecode"), Required, MaxLength(1), StringLength(1)]
		public string TypeCode
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_typecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_typecode"))
				    value = (string) backupAttributeCollection["chpqa_typecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_typecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Prime Mover Type
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Prime Mover Type
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_primemover_Type_chpqa_primemovertyp'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Type_chpqa_primemovertyp")]
		public PrimeMover[] PrimeMoversOfType
		{
			get => GetRelatedEntities<PrimeMover>("chpqa_chpqa_primemover_Type_chpqa_primemovertyp", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_primemover_Type_chpqa_primemovertyp", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfType(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemover", LogicalName, "chpqa_type", "chpqa_primemovertypeid", "chpqa_primemovertypeid", "chpqa_primemovertypeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<PrimeMover>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Type_chpqa_primemovertyp"), alreadyTracked); } catch { }
			    });
			if (PrimeMoversOfType == null || PrimeMoversOfType.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public PrimeMover[] LoadPrimeMoversOfType(IOrganizationService service, params string[] attributes)
		{
			return LoadPrimeMoversOfType(service, -1, -1, null, false, attributes);
		}

		public PrimeMover[] LoadPrimeMoversOfType(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadPrimeMoversOfType(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfType(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			PrimeMover[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemover", LogicalName, "chpqa_type", "chpqa_primemovertypeid", "chpqa_primemovertypeid", "chpqa_primemovertypeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (PrimeMoversOfType == null) { PrimeMoversOfType = resultArray; return; }
					PrimeMoversOfType = PrimeMoversOfType.Union(resultArray).Distinct<PrimeMover>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		public static class RelationNames {
			public static RelationName PrimeMoversOfType = new RelationName("PrimeMoversOfType");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["PrimeMoversOfType"] = new object[] { "PrimeMoversOfType", "chpqa_primemover", "chpqa_primemovertype", "chpqa_type", "chpqa_primemovertypeid", "chpqa_primemovertypeid", "chpqa_primemovertypeid", "chpqa_chpqa_primemover_Type_chpqa_primemovertyp", typeof (PrimeMover[]) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public PrimeMoverType(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_primemovertypeid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string Description = "chpqa_description";
			public const string Name = "chpqa_name";
			public const string PrimeMoverTypeId = "chpqa_primemovertypeid";
			public const string TypeCode = "chpqa_typecode";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string Description = "chpqa_Description";
				public const string Name = "chpqa_Name";
				public const string PrimeMoverTypeId = "chpqa_PrimeMoverTypeId";
				public const string TypeCode = "chpqa_TypeCode";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> Description { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Description"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> PrimeMoverTypeId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Prime Mover Type"},
					};

				public static IDictionary<int, string> TypeCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Type Code"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string PrimeMoversOfType = "chpqa_chpqa_primemover_Type_chpqa_primemovertyp";
			}
			
			public static class NToOne
			{

				public static class Lookups
				{
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Scheme

	/// <summary>
	/// 'chpqa_Scheme'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_scheme")]
	public partial class Scheme : GeneratedEntity<Scheme.RelationName>
	{
		public Scheme() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Scheme(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Scheme(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Scheme";
		public const string SchemaName = "chpqa_Scheme";
		public const string EntityLogicalName = "chpqa_scheme";
		public const int EntityTypeCode = 10627;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_schemeid")]
		public override System.Guid Id
		{
			get => (SchemeId == null || SchemeId == Guid.Empty) ? base.Id : SchemeId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_schemeid");
                    base.Id = value;
                } else {
				    SchemeId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_additionalinformation"), MaxLength(8000), StringLength(8000)]
		public string AdditionalInformation
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_additionalinformation");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_additionalinformation"))
				    value = (string) backupAttributeCollection["chpqa_additionalinformation"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_additionalinformation", value);
			}
		}

		[AttributeLogicalName("chpqa_company"), Required]
		public Guid? Company
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_company");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_company"))
				    value = (EntityReference) backupAttributeCollection["chpqa_company"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_company", new EntityReference("account", value.Value));
                else
	                SetAttributeValue("chpqa_company", value);
			}
		}

        public string CompanyName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_company");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_company"))
				    value = (EntityReference) backupAttributeCollection["chpqa_company"];
                return value?.Name;
            }
        }

		[Label("1033_name", "account", "accountid", "chpqa_company")]
        public IDictionary<int, string> CompanyLabels { get; set; }

		[AttributeLogicalName("chpqa_fuelbillfrequency"), Required]
		public GlobalEnums.FuelBillFrequency? FuelBillFrequency
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_fuelbillfrequency");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelbillfrequency"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_fuelbillfrequency"];
				return (GlobalEnums.FuelBillFrequency?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_fuelbillfrequency", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_fuelbillfrequency", value);
			}
		}

        public IDictionary<int, string> FuelBillFrequencyLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_fuelbillfrequency");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelbillfrequency"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_fuelbillfrequency"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_fuelbillfrequency", value.Value, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_ref"), Required, MaxLength(100), StringLength(100)]
		public string Ref
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_ref");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_ref"))
				    value = (string) backupAttributeCollection["chpqa_ref"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_ref", value);
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_SchemeId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_schemeid")]
		public Guid? SchemeId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_schemeid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_schemeid"))
				    value = (Guid?) backupAttributeCollection["chpqa_schemeid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_schemeid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

		[AttributeLogicalName("chpqa_schemeref"), Required, MaxLength(100), StringLength(100)]
		public string SchemeRef
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_schemeref");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_schemeref"))
				    value = (string) backupAttributeCollection["chpqa_schemeref"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_schemeref", value);
			}
		}

		[AttributeLogicalName("chpqa_sector"), Required]
		public GlobalEnums.Sector? Sector
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_sector");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_sector"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_sector"];
				return (GlobalEnums.Sector?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_sector", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_sector", value);
			}
		}

        public IDictionary<int, string> SectorLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_sector");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_sector"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_sector"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_sector", value.Value, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_site"), Required]
		public Guid? Site
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_site");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_site"))
				    value = (EntityReference) backupAttributeCollection["chpqa_site"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_site", new EntityReference("chpqa_site", value.Value));
                else
	                SetAttributeValue("chpqa_site", value);
			}
		}

        public string SiteName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_site");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_site"))
				    value = (EntityReference) backupAttributeCollection["chpqa_site"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_name", "chpqa_site", "chpqa_siteid", "chpqa_site")]
        public IDictionary<int, string> SiteLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Scheme
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Scheme
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_boiler_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_boiler_Scheme_chpqa_scheme")]
		public Boiler[] BoilersOfScheme
		{
			get => GetRelatedEntities<Boiler>("chpqa_chpqa_boiler_Scheme_chpqa_scheme", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_boiler_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Boiler[] LoadBoilersOfScheme(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_boiler", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Boiler>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_boiler_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			    });
			if (BoilersOfScheme == null || BoilersOfScheme.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Boiler[] LoadBoilersOfScheme(IOrganizationService service, params string[] attributes)
		{
			return LoadBoilersOfScheme(service, -1, -1, null, false, attributes);
		}

		public Boiler[] LoadBoilersOfScheme(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadBoilersOfScheme(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Boiler[] LoadBoilersOfScheme(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Boiler[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_boiler", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (BoilersOfScheme == null) { BoilersOfScheme = resultArray; return; }
					BoilersOfScheme = BoilersOfScheme.Union(resultArray).Distinct<Boiler>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_diagram_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_diagram_Scheme_chpqa_scheme")]
		public Diagram[] DiagramsOfScheme
		{
			get => GetRelatedEntities<Diagram>("chpqa_chpqa_diagram_Scheme_chpqa_scheme", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_diagram_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Diagram[] LoadDiagramsOfScheme(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_diagram", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Diagram>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_diagram_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			    });
			if (DiagramsOfScheme == null || DiagramsOfScheme.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Diagram[] LoadDiagramsOfScheme(IOrganizationService service, params string[] attributes)
		{
			return LoadDiagramsOfScheme(service, -1, -1, null, false, attributes);
		}

		public Diagram[] LoadDiagramsOfScheme(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadDiagramsOfScheme(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Diagram[] LoadDiagramsOfScheme(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Diagram[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_diagram", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Diagram>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Diagram>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (DiagramsOfScheme == null) { DiagramsOfScheme = resultArray; return; }
					DiagramsOfScheme = DiagramsOfScheme.Union(resultArray).Distinct<Diagram>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_primemover_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_primemover_Scheme_chpqa_scheme")]
		public PrimeMover[] PrimeMoversOfScheme
		{
			get => GetRelatedEntities<PrimeMover>("chpqa_chpqa_primemover_Scheme_chpqa_scheme", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_primemover_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfScheme(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemover", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<PrimeMover>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_primemover_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			    });
			if (PrimeMoversOfScheme == null || PrimeMoversOfScheme.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public PrimeMover[] LoadPrimeMoversOfScheme(IOrganizationService service, params string[] attributes)
		{
			return LoadPrimeMoversOfScheme(service, -1, -1, null, false, attributes);
		}

		public PrimeMover[] LoadPrimeMoversOfScheme(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadPrimeMoversOfScheme(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfScheme(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			PrimeMover[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemover", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (PrimeMoversOfScheme == null) { PrimeMoversOfScheme = resultArray; return; }
					PrimeMoversOfScheme = PrimeMoversOfScheme.Union(resultArray).Distinct<PrimeMover>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_submission_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_submission_Scheme_chpqa_scheme")]
		public Submission[] SubmissionsOfScheme
		{
			get => GetRelatedEntities<Submission>("chpqa_chpqa_submission_Scheme_chpqa_scheme", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_submission_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Submission[] LoadSubmissionsOfScheme(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_submission", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Submission>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_submission_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			    });
			if (SubmissionsOfScheme == null || SubmissionsOfScheme.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Submission[] LoadSubmissionsOfScheme(IOrganizationService service, params string[] attributes)
		{
			return LoadSubmissionsOfScheme(service, -1, -1, null, false, attributes);
		}

		public Submission[] LoadSubmissionsOfScheme(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadSubmissionsOfScheme(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Submission[] LoadSubmissionsOfScheme(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Submission[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_submission", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Submission>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Submission>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (SubmissionsOfScheme == null) { SubmissionsOfScheme = resultArray; return; }
					SubmissionsOfScheme = SubmissionsOfScheme.Union(resultArray).Distinct<Submission>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_Meter_chpqa_Scheme_chpqa_Scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_Meter_chpqa_Scheme_chpqa_Scheme")]
		public Meter[] MetersOfScheme
		{
			get => GetRelatedEntities<Meter>("chpqa_Meter_chpqa_Scheme_chpqa_Scheme", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_Meter_chpqa_Scheme_chpqa_Scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Meter[] LoadMetersOfScheme(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_meter", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Meter>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_Meter_chpqa_Scheme_chpqa_Scheme"), alreadyTracked); } catch { }
			    });
			if (MetersOfScheme == null || MetersOfScheme.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Meter[] LoadMetersOfScheme(IOrganizationService service, params string[] attributes)
		{
			return LoadMetersOfScheme(service, -1, -1, null, false, attributes);
		}

		public Meter[] LoadMetersOfScheme(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadMetersOfScheme(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Meter[] LoadMetersOfScheme(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Meter[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_meter", LogicalName, "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Meter>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Meter>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (MetersOfScheme == null) { MetersOfScheme = resultArray; return; }
					MetersOfScheme = MetersOfScheme.Union(resultArray).Distinct<Meter>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_scheme_Site_chpqa_site'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_scheme_Site_chpqa_site"), AttributeLogicalName("chpqa_site")]
		public Site SiteAsSite
		{
			get => GetRelatedEntity<Site>("chpqa_chpqa_scheme_Site_chpqa_site", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Site>("chpqa_chpqa_scheme_Site_chpqa_site", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Site LoadSiteAsSite(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_site", LogicalName, "chpqa_siteid", "chpqa_site", "chpqa_schemeid", "chpqa_schemeid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_scheme_Site_chpqa_site"), alreadyTracked); } catch { }
			if (SiteAsSite == null || SiteAsSite.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Site>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Site LoadSiteAsSite(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Site result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_site", LogicalName, "chpqa_siteid", "chpqa_site", "chpqa_schemeid", "chpqa_schemeid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SiteAsSite = result = (resultTemp == null ? null : resultTemp.ToEntity<Site>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName BoilersOfScheme = new RelationName("BoilersOfScheme");
			public static RelationName DiagramsOfScheme = new RelationName("DiagramsOfScheme");
			public static RelationName PrimeMoversOfScheme = new RelationName("PrimeMoversOfScheme");
			public static RelationName SubmissionsOfScheme = new RelationName("SubmissionsOfScheme");
			public static RelationName MetersOfScheme = new RelationName("MetersOfScheme");
			public static RelationName SiteAsSite = new RelationName("SiteAsSite");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["BoilersOfScheme"] = new object[] { "BoilersOfScheme", "chpqa_boiler", "chpqa_scheme", "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid", "chpqa_chpqa_boiler_Scheme_chpqa_scheme", typeof (Boiler[]) };
			relationProperties["DiagramsOfScheme"] = new object[] { "DiagramsOfScheme", "chpqa_diagram", "chpqa_scheme", "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid", "chpqa_chpqa_diagram_Scheme_chpqa_scheme", typeof (Diagram[]) };
			relationProperties["PrimeMoversOfScheme"] = new object[] { "PrimeMoversOfScheme", "chpqa_primemover", "chpqa_scheme", "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid", "chpqa_chpqa_primemover_Scheme_chpqa_scheme", typeof (PrimeMover[]) };
			relationProperties["SubmissionsOfScheme"] = new object[] { "SubmissionsOfScheme", "chpqa_submission", "chpqa_scheme", "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid", "chpqa_chpqa_submission_Scheme_chpqa_scheme", typeof (Submission[]) };
			relationProperties["MetersOfScheme"] = new object[] { "MetersOfScheme", "chpqa_meter", "chpqa_scheme", "chpqa_scheme", "chpqa_schemeid", "chpqa_schemeid", "chpqa_schemeid", "chpqa_Meter_chpqa_Scheme_chpqa_Scheme", typeof (Meter[]) };
			relationProperties["SiteAsSite"] = new object[] { "SiteAsSite", "chpqa_site", "chpqa_scheme", "chpqa_siteid", "chpqa_site", "chpqa_schemeid", "chpqa_schemeid", "chpqa_chpqa_scheme_Site_chpqa_site", typeof (Site) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Scheme(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_schemeid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string FuelBillFrequency = "chpqa_fuelbillfrequency";
				public const string Sector = "chpqa_sector";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> FuelBillFrequency { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "Monthly"},
								{709570001, "Quarterly"},
								{709570002, "Annually"},
								{709570003, "Other"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> Sector { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "Chemical industry"},
								{709570001, "Commerce"},
								{709570002, "Construction"},
								{709570003, "Electrical and instrument engineering"},
								{709570004, "Extraction, mining and agglomeration"},
								{709570005, "Food, beverages and tobacco"},
								{303150001, "Health"},
								{709570006, "Iron and steel"},
								{709570007, "Mechanical engineering and metal products"},
								{709570008, "Mineral products (eg glass, cement, bricks)"},
								{709570009, "Non ferrous metals"},
								{709570010, "Oil refineries"},
								{709570011, "Other industrial branches"},
								{709570012, "Paper, publishing and printing"},
								{709570013, "Power generation"},
								{709570014, "Public Administration"},
								{709570015, "Sewage treatment"},
								{709570016, "Textiles, clothing and footwear"},
								{709570017, "Transport"},
								{709570018, "Vehicles"},
								{709570019, "Other"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string AdditionalInformation = "chpqa_additionalinformation";
			public const string Company = "chpqa_company";
			public const string FuelBillFrequency = "chpqa_fuelbillfrequency";
			public const string Ref = "chpqa_ref";
			public const string SchemeId = "chpqa_schemeid";
			public const string SchemeRef = "chpqa_schemeref";
			public const string Sector = "chpqa_sector";
			public const string Site = "chpqa_site";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string AdditionalInformation = "chpqa_AdditionalInformation";
				public const string Company = "chpqa_Company";
				public const string FuelBillFrequency = "chpqa_FuelBillFrequency";
				public const string Ref = "chpqa_Ref";
				public const string SchemeId = "chpqa_SchemeId";
				public const string SchemeRef = "chpqa_SchemeRef";
				public const string Sector = "chpqa_Sector";
				public const string Site = "chpqa_Site";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> AdditionalInformation { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Additional Information"},
					};

				public static IDictionary<int, string> Company { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Company"},
					};

				public static IDictionary<int, string> FuelBillFrequency { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel Bill Frequency"},
					};

				public static IDictionary<int, string> Ref { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Ref"},
					};

				public static IDictionary<int, string> SchemeId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme"},
					};

				public static IDictionary<int, string> SchemeRef { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme Ref"},
					};

				public static IDictionary<int, string> Sector { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Sector"},
					};

				public static IDictionary<int, string> Site { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Site"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string BoilersOfScheme = "chpqa_chpqa_boiler_Scheme_chpqa_scheme";
				public const string DiagramsOfScheme = "chpqa_chpqa_diagram_Scheme_chpqa_scheme";
				public const string PrimeMoversOfScheme = "chpqa_chpqa_primemover_Scheme_chpqa_scheme";
				public const string SubmissionsOfScheme = "chpqa_chpqa_submission_Scheme_chpqa_scheme";
				public const string MetersOfScheme = "chpqa_Meter_chpqa_Scheme_chpqa_Scheme";
			}
			
			public static class NToOne
			{
				public const string SiteAsSite = "chpqa_chpqa_scheme_Site_chpqa_site";

				public static class Lookups
				{
					public const string SiteAsSite = "chpqa_site";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Site

	/// <summary>
	/// 'chpqa_Site'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_site")]
	public partial class Site : GeneratedEntity<Site.RelationName>
	{
		public Site() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Site(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Site(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Site";
		public const string SchemaName = "chpqa_Site";
		public const string EntityLogicalName = "chpqa_site";
		public const int EntityTypeCode = 10806;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_siteid")]
		public override System.Guid Id
		{
			get => (SiteId == null || SiteId == Guid.Empty) ? base.Id : SiteId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_siteid");
                    base.Id = value;
                } else {
				    SiteId = value;
                }
			}
		}

        /// <summary>
        /// [MaxLength=100] 
		/// 'chpqa_Country'.<br />
        /// Type the country for the site's address.
        /// </summary>
		[AttributeLogicalName("chpqa_country"), MaxLength(100), StringLength(100)]
		public string Country
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_country");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_country"))
				    value = (string) backupAttributeCollection["chpqa_country"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_country", value);
			}
		}

        /// <summary>
        /// [MaxLength=100] 
		/// 'chpqa_County'.<br />
        /// Type the county for the site's address.
        /// </summary>
		[AttributeLogicalName("chpqa_county"), MaxLength(100), StringLength(100)]
		public string County
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_county");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_county"))
				    value = (string) backupAttributeCollection["chpqa_county"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_county", value);
			}
		}

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Name
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_postcode"), Required, MaxLength(12), StringLength(12)]
		public string Postcode
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_postcode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_postcode"))
				    value = (string) backupAttributeCollection["chpqa_postcode"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_postcode", value);
			}
		}

        /// <summary>
        ///  
		/// 'chpqa_SiteId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_siteid")]
		public Guid? SiteId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_siteid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_siteid"))
				    value = (Guid?) backupAttributeCollection["chpqa_siteid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_siteid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

        /// <summary>
        /// [Required][MaxLength=100] 
		/// 'chpqa_Street1'.<br />
        /// Type the first line of the site's address to help identify the location.
        /// </summary>
		[AttributeLogicalName("chpqa_street1"), Required, MaxLength(100), StringLength(100)]
		public string Street1
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_street1");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_street1"))
				    value = (string) backupAttributeCollection["chpqa_street1"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_street1", value);
			}
		}

        /// <summary>
        /// [MaxLength=100] 
		/// 'chpqa_Street2'.<br />
        /// Type the second line of the site's address.
        /// </summary>
		[AttributeLogicalName("chpqa_street2"), MaxLength(100), StringLength(100)]
		public string Street2
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_street2");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_street2"))
				    value = (string) backupAttributeCollection["chpqa_street2"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_street2", value);
			}
		}

        /// <summary>
        /// [Required][MaxLength=100] 
		/// 'chpqa_TownCity'.<br />
        /// Type the town or city for the site's address to help identify the location.
        /// </summary>
		[AttributeLogicalName("chpqa_towncity"), Required, MaxLength(100), StringLength(100)]
		public string TownCity
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_towncity");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_towncity"))
				    value = (string) backupAttributeCollection["chpqa_towncity"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_towncity", value);
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Site
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Site
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_chpqa_scheme_Site_chpqa_site'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_scheme_Site_chpqa_site")]
		public Scheme[] SchemesOfSite
		{
			get => GetRelatedEntities<Scheme>("chpqa_chpqa_scheme_Site_chpqa_site", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_chpqa_scheme_Site_chpqa_site", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Scheme[] LoadSchemesOfSite(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_scheme", LogicalName, "chpqa_site", "chpqa_siteid", "chpqa_siteid", "chpqa_siteid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Scheme>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_chpqa_scheme_Site_chpqa_site"), alreadyTracked); } catch { }
			    });
			if (SchemesOfSite == null || SchemesOfSite.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Scheme[] LoadSchemesOfSite(IOrganizationService service, params string[] attributes)
		{
			return LoadSchemesOfSite(service, -1, -1, null, false, attributes);
		}

		public Scheme[] LoadSchemesOfSite(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadSchemesOfSite(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Scheme[] LoadSchemesOfSite(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Scheme[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_scheme", LogicalName, "chpqa_site", "chpqa_siteid", "chpqa_siteid", "chpqa_siteid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Scheme>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Scheme>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (SchemesOfSite == null) { SchemesOfSite = resultArray; return; }
					SchemesOfSite = SchemesOfSite.Union(resultArray).Distinct<Scheme>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		public static class RelationNames {
			public static RelationName SchemesOfSite = new RelationName("SchemesOfSite");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["SchemesOfSite"] = new object[] { "SchemesOfSite", "chpqa_scheme", "chpqa_site", "chpqa_site", "chpqa_siteid", "chpqa_siteid", "chpqa_siteid", "chpqa_chpqa_scheme_Site_chpqa_site", typeof (Scheme[]) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Site(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_siteid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string Country = "chpqa_country";
			public const string County = "chpqa_county";
			public const string Name = "chpqa_name";
			public const string Postcode = "chpqa_postcode";
			public const string SiteId = "chpqa_siteid";
			public const string Street1 = "chpqa_street1";
			public const string Street2 = "chpqa_street2";
			public const string TownCity = "chpqa_towncity";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string Country = "chpqa_Country";
				public const string County = "chpqa_County";
				public const string Name = "chpqa_Name";
				public const string Postcode = "chpqa_Postcode";
				public const string SiteId = "chpqa_SiteId";
				public const string Street1 = "chpqa_Street1";
				public const string Street2 = "chpqa_Street2";
				public const string TownCity = "chpqa_TownCity";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> Country { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Country"},
					};

				public static IDictionary<int, string> County { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "County"},
					};

				public static IDictionary<int, string> Name { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Name"},
					};

				public static IDictionary<int, string> Postcode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Postcode"},
					};

				public static IDictionary<int, string> SiteId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Site"},
					};

				public static IDictionary<int, string> Street1 { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Street 1"},
					};

				public static IDictionary<int, string> Street2 { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Street 2"},
					};

				public static IDictionary<int, string> TownCity { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Town / City"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string SchemesOfSite = "chpqa_chpqa_scheme_Site_chpqa_site";
			}
			
			public static class NToOne
			{

				public static class Lookups
				{
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	#region Submission

	/// <summary>
	/// 'chpqa_Submission'.<br />
	/// 
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("chpqa_submission")]
	public partial class Submission : GeneratedEntity<Submission.RelationName>
	{
		public Submission() : base(EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Submission(string[] keys, object[] values) : base(keys, values, EntityLogicalName)
		{ }
		
		/// <inheritdoc/>
		public Submission(object obj, Type limitingType) : base(obj, limitingType, EntityLogicalName)
		{ }

		public const string DisplayName = "Submission";
		public const string SchemaName = "chpqa_Submission";
		public const string EntityLogicalName = "chpqa_submission";
		public const int EntityTypeCode = 10801;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

		#region Attributes

		[AttributeLogicalName("chpqa_submissionid")]
		public override System.Guid Id
		{
			get => (SubmissionId == null || SubmissionId == Guid.Empty) ? base.Id : SubmissionId.GetValueOrDefault();
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("chpqa_submissionid");
                    base.Id = value;
                } else {
				    SubmissionId = value;
                }
			}
		}

		[AttributeLogicalName("chpqa_additionalinformation"), MaxLength(8000), StringLength(8000)]
		public string AdditionalInformation
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_additionalinformation");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_additionalinformation"))
				    value = (string) backupAttributeCollection["chpqa_additionalinformation"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_additionalinformation", value);
			}
		}

		[AttributeLogicalName("chpqa_fuelbillfrequency"), Required]
		public GlobalEnums.FuelBillFrequency? FuelBillFrequency
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_fuelbillfrequency");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelbillfrequency"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_fuelbillfrequency"];
				return (GlobalEnums.FuelBillFrequency?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_fuelbillfrequency", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_fuelbillfrequency", value);
			}
		}

        public IDictionary<int, string> FuelBillFrequencyLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_fuelbillfrequency");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_fuelbillfrequency"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_fuelbillfrequency"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_fuelbillfrequency", value.Value, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_name"), Required, MaxLength(100), StringLength(100)]
		public string Ref
		{
			get
			{
				var value = GetAttributeValue<string>("chpqa_name");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_name"))
				    value = (string) backupAttributeCollection["chpqa_name"];
			    return value;
			}
			set
			{
                SetAttributeValue("chpqa_name", value);
			}
		}

		[AttributeLogicalName("chpqa_scheme"), Required]
		public Guid? Scheme
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_scheme", new EntityReference("chpqa_scheme", value.Value));
                else
	                SetAttributeValue("chpqa_scheme", value);
			}
		}

        public string SchemeName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_scheme");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_scheme"))
				    value = (EntityReference) backupAttributeCollection["chpqa_scheme"];
                return value?.Name;
            }
        }

		[Label("1033_chpqa_ref", "chpqa_scheme", "chpqa_schemeid", "chpqa_scheme")]
        public IDictionary<int, string> SchemeLabels { get; set; }

		[AttributeLogicalName("chpqa_sector"), Required]
		public GlobalEnums.Sector? Sector
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("chpqa_sector");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_sector"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_sector"];
				return (GlobalEnums.Sector?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_sector", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("chpqa_sector", value);
			}
		}

        public IDictionary<int, string> SectorLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("chpqa_sector");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_sector"))
				    value = (OptionSetValue) backupAttributeCollection["chpqa_sector"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("chpqa_sector", value.Value, 1033) },
                        };
            }
        }

		[AttributeLogicalName("chpqa_site"), Required]
		public Guid? Site
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("chpqa_site");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_site"))
				    value = (EntityReference) backupAttributeCollection["chpqa_site"];
                return value?.Id;
			}
			set
			{
                if (value != null) SetAttributeValue("chpqa_site", new EntityReference("site", value.Value));
                else
	                SetAttributeValue("chpqa_site", value);
			}
		}

        public string SiteName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("chpqa_site");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_site"))
				    value = (EntityReference) backupAttributeCollection["chpqa_site"];
                return value?.Name;
            }
        }

		[Label("1033_name", "site", "siteid", "chpqa_site")]
        public IDictionary<int, string> SiteLabels { get; set; }

        /// <summary>
        ///  
		/// 'chpqa_SubmissionId'.<br />
        /// Unique identifier for entity instances
        /// </summary>
		[AttributeLogicalName("chpqa_submissionid")]
		public Guid? SubmissionId
		{
			get
			{
				var value = GetAttributeValue<Guid?>("chpqa_submissionid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("chpqa_submissionid"))
				    value = (Guid?) backupAttributeCollection["chpqa_submissionid"];
			    return value;
			}
			set
			{
                if (value != null)
	                SetAttributeValue("chpqa_submissionid", value);
				if (value != null) base.Id = value.Value;
				else Id = System.Guid.Empty;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedBy'.<br />
        /// Unique identifier of the user who created the record.
        /// </summary>
		[AttributeLogicalName("createdby")]
		public Guid? CreatedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Id;
			}
		}

        public string CreatedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdby"))
				    value = (EntityReference) backupAttributeCollection["createdby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdby")]
        public IDictionary<int, string> CreatedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'CreatedOn'.<br />
        /// Date and time when the record was created.
        /// </summary>
		[AttributeLogicalName("createdon")]
		public DateTime? CreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("createdon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdon"))
				    value = (DateTime?) backupAttributeCollection["createdon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'CreatedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who created the record.
        /// </summary>
		[AttributeLogicalName("createdonbehalfby")]
		public Guid? CreatedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Id;
			}
		}

        public string CreatedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("createdonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("createdonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["createdonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "createdonbehalfby")]
        public IDictionary<int, string> CreatedByDelegateLabels { get; set; }

        /// <summary>
        /// [Range(-2147483648, 2147483647)] 
		/// 'ImportSequenceNumber'.<br />
        /// Sequence number of the import that created this record.
        /// </summary>
		[AttributeLogicalName("importsequencenumber"), Range(-2147483648,2147483647)]
		public int? ImportSequenceNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("importsequencenumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("importsequencenumber"))
				    value = (int?) backupAttributeCollection["importsequencenumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("importsequencenumber", value);
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedBy'.<br />
        /// Unique identifier of the user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedby")]
		public Guid? ModifiedBy
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Id;
			}
		}

        public string ModifiedByName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedby"))
				    value = (EntityReference) backupAttributeCollection["modifiedby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedby")]
        public IDictionary<int, string> ModifiedByLabels { get; set; }

        /// <summary>
        ///  
		/// 'ModifiedOn'.<br />
        /// Date and time when the record was modified.
        /// </summary>
		[AttributeLogicalName("modifiedon")]
		public DateTime? ModifiedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("modifiedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedon"))
				    value = (DateTime?) backupAttributeCollection["modifiedon"];
			    return value;
			}
		}

        /// <summary>
        ///  
		/// 'ModifiedOnBehalfBy'.<br />
        /// Unique identifier of the delegate user who modified the record.
        /// </summary>
		[AttributeLogicalName("modifiedonbehalfby")]
		public Guid? ModifiedByDelegate
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Id;
			}
		}

        public string ModifiedByDelegateName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("modifiedonbehalfby");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("modifiedonbehalfby"))
				    value = (EntityReference) backupAttributeCollection["modifiedonbehalfby"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "modifiedonbehalfby")]
        public IDictionary<int, string> ModifiedByDelegateLabels { get; set; }

        /// <summary>
        ///  
		/// 'OverriddenCreatedOn'.<br />
        /// Date and time that the record was migrated.
        /// </summary>
		[AttributeLogicalName("overriddencreatedon")]
		public DateTime? RecordCreatedOn
		{
			get
			{
				var value = GetAttributeValue<DateTime?>("overriddencreatedon");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("overriddencreatedon"))
				    value = (DateTime?) backupAttributeCollection["overriddencreatedon"];
			    return value;
			}
			set
			{
                SetAttributeValue("overriddencreatedon", value);
			}
		}

        /// <summary>
        ///  
		/// 'OwnerId'.<br />
        /// Owner Id
        /// </summary>
		[AttributeLogicalName("ownerid")]
		public EntityReference Owner
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
			    return value;
			}
			set
			{
                SetAttributeValue("ownerid", value);
			}
		}

        public string OwnerName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("ownerid");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("ownerid"))
				    value = (EntityReference) backupAttributeCollection["ownerid"];
                return value?.Name;
            }
        }

        public IDictionary<int, string> OwnerLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningBusinessUnit'.<br />
        /// Unique identifier for the business unit that owns the record
        /// </summary>
		[AttributeLogicalName("owningbusinessunit")]
		public Guid? OwningBusinessUnit
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Id;
			}
		}

        public string OwningBusinessUnitName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningbusinessunit");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningbusinessunit"))
				    value = (EntityReference) backupAttributeCollection["owningbusinessunit"];
                return value?.Name;
            }
        }

		[Label("1033_name", "businessunit", "businessunitid", "owningbusinessunit")]
        public IDictionary<int, string> OwningBusinessUnitLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningTeam'.<br />
        /// Unique identifier for the team that owns the record.
        /// </summary>
		[AttributeLogicalName("owningteam")]
		public Guid? OwningTeam
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Id;
			}
		}

        public string OwningTeamName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owningteam");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owningteam"))
				    value = (EntityReference) backupAttributeCollection["owningteam"];
                return value?.Name;
            }
        }

		[Label("1033_name", "team", "teamid", "owningteam")]
        public IDictionary<int, string> OwningTeamLabels { get; set; }

        /// <summary>
        ///  
		/// 'OwningUser'.<br />
        /// Unique identifier for the user that owns the record.
        /// </summary>
		[AttributeLogicalName("owninguser")]
		public Guid? OwningUser
		{
			get
			{
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Id;
			}
		}

        public string OwningUserName
        {
		    get
		    {
				var value = GetAttributeValue<EntityReference>("owninguser");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("owninguser"))
				    value = (EntityReference) backupAttributeCollection["owninguser"];
                return value?.Name;
            }
        }

		[Label("1033_fullname", "systemuser", "systemuserid", "owninguser")]
        public IDictionary<int, string> OwningUserLabels { get; set; }

        /// <summary>
        ///  
		/// 'statecode'.<br />
        /// Status of the Submission
        /// </summary>
		[AttributeLogicalName("statecode")]
		public StatusEnum? Status
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
				return (StatusEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statecode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statecode", value);
			}
		}

        public IDictionary<int, string> StatusLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statecode"))
				    value = (OptionSetValue) backupAttributeCollection["statecode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statecode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        ///  
		/// 'statuscode'.<br />
        /// Reason for the status of the Submission
        /// </summary>
		[AttributeLogicalName("statuscode")]
		public StatusReasonEnum? StatusReason
		{
			get
			{
				var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
				return (StatusReasonEnum?)value?.Value;
			}
			set
			{
                if (value != null) SetAttributeValue("statuscode", new OptionSetValue((int) value.Value));
                else
	                SetAttributeValue("statuscode", value);
			}
		}

        public IDictionary<int, string> StatusReasonLabels
        {
		    get
		    {
                var value = GetAttributeValue<OptionSetValue>("statuscode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("statuscode"))
				    value = (OptionSetValue) backupAttributeCollection["statuscode"];
                if (value == null) return null;
                return new Dictionary<int, string>
                        {
                             { 1033, Enums.GetLabel("statuscode", value.Value, 1033) },
                        };
            }
        }

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'TimeZoneRuleVersionNumber'.<br />
        /// For internal use only.
        /// </summary>
		[AttributeLogicalName("timezoneruleversionnumber"), Range(-1,2147483647)]
		public int? TimeZoneRuleVersionNumber
		{
			get
			{
				var value = GetAttributeValue<int?>("timezoneruleversionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("timezoneruleversionnumber"))
				    value = (int?) backupAttributeCollection["timezoneruleversionnumber"];
			    return value;
			}
			set
			{
                SetAttributeValue("timezoneruleversionnumber", value);
			}
		}

        /// <summary>
        /// [Range(-1, 2147483647)] 
		/// 'UTCConversionTimeZoneCode'.<br />
        /// Time zone code that was in use when the record was created.
        /// </summary>
		[AttributeLogicalName("utcconversiontimezonecode"), Range(-1,2147483647)]
		public int? UTCConversionTimeZoneCode
		{
			get
			{
				var value = GetAttributeValue<int?>("utcconversiontimezonecode");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("utcconversiontimezonecode"))
				    value = (int?) backupAttributeCollection["utcconversiontimezonecode"];
			    return value;
			}
			set
			{
                SetAttributeValue("utcconversiontimezonecode", value);
			}
		}

        /// <summary>
        ///  
		/// 'VersionNumber'.<br />
        /// Version Number
        /// </summary>
		[AttributeLogicalName("versionnumber")]
		public long? VersionNumber
		{
			get
			{
				var value = GetAttributeValue<long?>("versionnumber");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("versionnumber"))
				    value = (long?) backupAttributeCollection["versionnumber"];
			    return value;
			}
		}

		#endregion

		#region Relationships

		
		/// <summary>
		/// 1:N, 'chpqa_Boiler_chpqa_Submission_chpqa_Submi'
		/// </summary>
		[RelationshipSchemaName("chpqa_Boiler_chpqa_Submission_chpqa_Submi")]
		public Boiler[] BoilersOfSubmission
		{
			get => GetRelatedEntities<Boiler>("chpqa_Boiler_chpqa_Submission_chpqa_Submi", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_Boiler_chpqa_Submission_chpqa_Submi", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Boiler[] LoadBoilersOfSubmission(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_boiler", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Boiler>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_Boiler_chpqa_Submission_chpqa_Submi"), alreadyTracked); } catch { }
			    });
			if (BoilersOfSubmission == null || BoilersOfSubmission.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Boiler[] LoadBoilersOfSubmission(IOrganizationService service, params string[] attributes)
		{
			return LoadBoilersOfSubmission(service, -1, -1, null, false, attributes);
		}

		public Boiler[] LoadBoilersOfSubmission(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadBoilersOfSubmission(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Boiler[] LoadBoilersOfSubmission(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Boiler[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_boiler", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Boiler>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (BoilersOfSubmission == null) { BoilersOfSubmission = resultArray; return; }
					BoilersOfSubmission = BoilersOfSubmission.Union(resultArray).Distinct<Boiler>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_Diagram_chpqa_Submission_chpqa_Subm'
		/// </summary>
		[RelationshipSchemaName("chpqa_Diagram_chpqa_Submission_chpqa_Subm")]
		public Diagram[] DiagramsOfSubmission
		{
			get => GetRelatedEntities<Diagram>("chpqa_Diagram_chpqa_Submission_chpqa_Subm", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_Diagram_chpqa_Submission_chpqa_Subm", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Diagram[] LoadDiagramsOfSubmission(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_diagram", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Diagram>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_Diagram_chpqa_Submission_chpqa_Subm"), alreadyTracked); } catch { }
			    });
			if (DiagramsOfSubmission == null || DiagramsOfSubmission.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Diagram[] LoadDiagramsOfSubmission(IOrganizationService service, params string[] attributes)
		{
			return LoadDiagramsOfSubmission(service, -1, -1, null, false, attributes);
		}

		public Diagram[] LoadDiagramsOfSubmission(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadDiagramsOfSubmission(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Diagram[] LoadDiagramsOfSubmission(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Diagram[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_diagram", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Diagram>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Diagram>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (DiagramsOfSubmission == null) { DiagramsOfSubmission = resultArray; return; }
					DiagramsOfSubmission = DiagramsOfSubmission.Union(resultArray).Distinct<Diagram>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_Meter_chpqa_Submission_chpqa_Submis'
		/// </summary>
		[RelationshipSchemaName("chpqa_Meter_chpqa_Submission_chpqa_Submis")]
		public Meter[] MetersOfSubmission
		{
			get => GetRelatedEntities<Meter>("chpqa_Meter_chpqa_Submission_chpqa_Submis", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_Meter_chpqa_Submission_chpqa_Submis", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Meter[] LoadMetersOfSubmission(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_meter", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<Meter>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_Meter_chpqa_Submission_chpqa_Submis"), alreadyTracked); } catch { }
			    });
			if (MetersOfSubmission == null || MetersOfSubmission.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public Meter[] LoadMetersOfSubmission(IOrganizationService service, params string[] attributes)
		{
			return LoadMetersOfSubmission(service, -1, -1, null, false, attributes);
		}

		public Meter[] LoadMetersOfSubmission(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadMetersOfSubmission(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Meter[] LoadMetersOfSubmission(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			Meter[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_meter", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<Meter>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<Meter>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (MetersOfSubmission == null) { MetersOfSubmission = resultArray; return; }
					MetersOfSubmission = MetersOfSubmission.Union(resultArray).Distinct<Meter>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// 1:N, 'chpqa_PrimeMover_chpqa_Submission_chpqa_S'
		/// </summary>
		[RelationshipSchemaName("chpqa_PrimeMover_chpqa_Submission_chpqa_S")]
		public PrimeMover[] PrimeMoversOfSubmission
		{
			get => GetRelatedEntities<PrimeMover>("chpqa_PrimeMover_chpqa_Submission_chpqa_S", null)?.ToArray();
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                value?.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities("chpqa_PrimeMover_chpqa_Submission_chpqa_S", null, value);
			}
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfSubmission(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_primemover", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter, attributes: attributes).Select(entity => entity.ToEntity<PrimeMover>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result,
				entity =>
			    {
				    var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				    if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
					try { context.AttachLink(this, new Relationship("chpqa_PrimeMover_chpqa_Submission_chpqa_S"), alreadyTracked); } catch { }
			    });
			if (PrimeMoversOfSubmission == null || PrimeMoversOfSubmission.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public PrimeMover[] LoadPrimeMoversOfSubmission(IOrganizationService service, params string[] attributes)
		{
			return LoadPrimeMoversOfSubmission(service, -1, -1, null, false, attributes);
		}

		public PrimeMover[] LoadPrimeMoversOfSubmission(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadPrimeMoversOfSubmission(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public PrimeMover[] LoadPrimeMoversOfSubmission(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			PrimeMover[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_primemover", LogicalName, "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid",
				recordCountLimit, page, filter: filter, attributes: attributes));
			var queryAction = queryActionObject.Action =
				result => {
					var response = result as RetrieveMultipleResponse;
					resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray()
	    				: response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<PrimeMover>()).ToArray();
					DeferredQueriesList.Remove(queryActionObject);
					if (resultArray.Length <= 0) return;
					if (PrimeMoversOfSubmission == null) { PrimeMoversOfSubmission = resultArray; return; }
					PrimeMoversOfSubmission = PrimeMoversOfSubmission.Union(resultArray).Distinct<PrimeMover>(new EntityComparer()).ToArray();
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
		
		/// <summary>
		/// N:1, 'chpqa_chpqa_submission_Scheme_chpqa_scheme'
		/// </summary>
		[RelationshipSchemaName("chpqa_chpqa_submission_Scheme_chpqa_scheme"), AttributeLogicalName("chpqa_scheme")]
		public Scheme SchemeAsScheme
		{
			get => GetRelatedEntity<Scheme>("chpqa_chpqa_submission_Scheme_chpqa_scheme", null);
			set
			{
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null) value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<Scheme>("chpqa_chpqa_submission_Scheme_chpqa_scheme", null, value);
			}
		}

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_submissionid", "chpqa_submissionid",
				-1, -1, null, attributes: attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("chpqa_chpqa_submission_Scheme_chpqa_scheme"), alreadyTracked); } catch { }
			if (SchemeAsScheme == null || SchemeAsScheme.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<Scheme>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public Scheme LoadSchemeAsScheme(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
					"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			Scheme result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "chpqa_scheme", LogicalName, "chpqa_schemeid", "chpqa_scheme", "chpqa_submissionid", "chpqa_submissionid",
					-1, -1, filter: null, attributes: attributes));
			var queryAction = queryActionObject.Action =
				resultQ => {
					var response = resultQ as RetrieveMultipleResponse;
					var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
						: response.EntityCollection.Entities.FirstOrDefault();
					DeferredQueriesList.Remove(queryActionObject);
					SchemeAsScheme = result = (resultTemp == null ? null : resultTemp.ToEntity<Scheme>());
				};
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
		
		public static class RelationNames {
			public static RelationName BoilersOfSubmission = new RelationName("BoilersOfSubmission");
			public static RelationName DiagramsOfSubmission = new RelationName("DiagramsOfSubmission");
			public static RelationName MetersOfSubmission = new RelationName("MetersOfSubmission");
			public static RelationName PrimeMoversOfSubmission = new RelationName("PrimeMoversOfSubmission");
			public static RelationName SchemeAsScheme = new RelationName("SchemeAsScheme");
		}

		public override IDictionary<string, object[]> RelationProperties { get {
			if (relationProperties != null) return relationProperties;
			relationProperties = new Dictionary<string, object[]>();
			relationProperties["BoilersOfSubmission"] = new object[] { "BoilersOfSubmission", "chpqa_boiler", "chpqa_submission", "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid", "chpqa_Boiler_chpqa_Submission_chpqa_Submi", typeof (Boiler[]) };
			relationProperties["DiagramsOfSubmission"] = new object[] { "DiagramsOfSubmission", "chpqa_diagram", "chpqa_submission", "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid", "chpqa_Diagram_chpqa_Submission_chpqa_Subm", typeof (Diagram[]) };
			relationProperties["MetersOfSubmission"] = new object[] { "MetersOfSubmission", "chpqa_meter", "chpqa_submission", "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid", "chpqa_Meter_chpqa_Submission_chpqa_Submis", typeof (Meter[]) };
			relationProperties["PrimeMoversOfSubmission"] = new object[] { "PrimeMoversOfSubmission", "chpqa_primemover", "chpqa_submission", "chpqa_submission", "chpqa_submissionid", "chpqa_submissionid", "chpqa_submissionid", "chpqa_PrimeMover_chpqa_Submission_chpqa_S", typeof (PrimeMover[]) };
			relationProperties["SchemeAsScheme"] = new object[] { "SchemeAsScheme", "chpqa_scheme", "chpqa_submission", "chpqa_schemeid", "chpqa_scheme", "chpqa_submissionid", "chpqa_submissionid", "chpqa_chpqa_submission_Scheme_chpqa_scheme", typeof (Scheme) };
			return relationProperties; } }

		#endregion

		/// <inheritdoc/>
		public Submission(object obj) : base(obj, EntityLogicalName)
		{
            foreach (var p in obj.GetType().GetProperties())
            {
                var value = p.GetValue(obj, null);
                if (p.PropertyType == typeof(Guid))
                {
                    base.Id = (Guid)value;
                    Attributes["chpqa_submissionid"] = base.Id;
                }
                else if (p.Name == "FormattedValues")
                {
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

		#region Label/value pairs

		public enum StatusEnum
		{
			Active = 0,
			Inactive = 1,
		}
	
		public enum StatusReasonEnum
		{
			Active = 1,
			Inactive = 2,
		}
	
		#endregion

		#region Metadata

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
				public const string FuelBillFrequency = "chpqa_fuelbillfrequency";
				public const string Sector = "chpqa_sector";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, IDictionary<int, string>> FuelBillFrequency { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "Monthly"},
								{709570001, "Quarterly"},
								{709570002, "Annually"},
								{709570003, "Other"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> Sector { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{709570000, "Chemical industry"},
								{709570001, "Commerce"},
								{709570002, "Construction"},
								{709570003, "Electrical and instrument engineering"},
								{709570004, "Extraction, mining and agglomeration"},
								{709570005, "Food, beverages and tobacco"},
								{303150001, "Health"},
								{709570006, "Iron and steel"},
								{709570007, "Mechanical engineering and metal products"},
								{709570008, "Mineral products (eg glass, cement, bricks)"},
								{709570009, "Non ferrous metals"},
								{709570010, "Oil refineries"},
								{709570011, "Other industrial branches"},
								{709570012, "Paper, publishing and printing"},
								{709570013, "Power generation"},
								{709570014, "Public Administration"},
								{709570015, "Sewage treatment"},
								{709570016, "Textiles, clothing and footwear"},
								{709570017, "Transport"},
								{709570018, "Vehicles"},
								{709570019, "Other"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> Status { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{0, "Active"},
								{1, "Inactive"},
							}
						},
					};

				public static IDictionary<int, IDictionary<int, string>> StatusReason { get; set; } =
					new Dictionary<int, IDictionary<int, string>>
					{
						{ 1033,
							new Dictionary<int, string>
							{
								{1, "Active"},
								{2, "Inactive"},
							}
						},
					};

			}

			#endregion
		}

		#endregion

		#region Fields

		public static class Fields
		{
			#region Logical names

			public const string AdditionalInformation = "chpqa_additionalinformation";
			public const string FuelBillFrequency = "chpqa_fuelbillfrequency";
			public const string Ref = "chpqa_name";
			public const string Scheme = "chpqa_scheme";
			public const string Sector = "chpqa_sector";
			public const string Site = "chpqa_site";
			public const string SubmissionId = "chpqa_submissionid";
			public const string CreatedBy = "createdby";
			public const string CreatedOn = "createdon";
			public const string CreatedByDelegate = "createdonbehalfby";
			public const string ImportSequenceNumber = "importsequencenumber";
			public const string ModifiedBy = "modifiedby";
			public const string ModifiedOn = "modifiedon";
			public const string ModifiedByDelegate = "modifiedonbehalfby";
			public const string RecordCreatedOn = "overriddencreatedon";
			public const string Owner = "ownerid";
			public const string OwningBusinessUnit = "owningbusinessunit";
			public const string OwningTeam = "owningteam";
			public const string OwningUser = "owninguser";
			public const string Status = "statecode";
			public const string StatusReason = "statuscode";
			public const string TimeZoneRuleVersionNumber = "timezoneruleversionnumber";
			public const string UTCConversionTimeZoneCode = "utcconversiontimezonecode";
			public const string VersionNumber = "versionnumber";

			#endregion

			#region Schema names

			public static class Schema
			{
				public const string AdditionalInformation = "chpqa_AdditionalInformation";
				public const string FuelBillFrequency = "chpqa_FuelBillFrequency";
				public const string Ref = "chpqa_Name";
				public const string Scheme = "chpqa_Scheme";
				public const string Sector = "chpqa_Sector";
				public const string Site = "chpqa_Site";
				public const string SubmissionId = "chpqa_SubmissionId";
				public const string CreatedBy = "CreatedBy";
				public const string CreatedOn = "CreatedOn";
				public const string CreatedByDelegate = "CreatedOnBehalfBy";
				public const string ImportSequenceNumber = "ImportSequenceNumber";
				public const string ModifiedBy = "ModifiedBy";
				public const string ModifiedOn = "ModifiedOn";
				public const string ModifiedByDelegate = "ModifiedOnBehalfBy";
				public const string RecordCreatedOn = "OverriddenCreatedOn";
				public const string Owner = "OwnerId";
				public const string OwningBusinessUnit = "OwningBusinessUnit";
				public const string OwningTeam = "OwningTeam";
				public const string OwningUser = "OwningUser";
				public const string Status = "statecode";
				public const string StatusReason = "statuscode";
				public const string TimeZoneRuleVersionNumber = "TimeZoneRuleVersionNumber";
				public const string UTCConversionTimeZoneCode = "UTCConversionTimeZoneCode";
				public const string VersionNumber = "VersionNumber";
			}

			#endregion

			#region Labels

			public static class Labels
			{
				public static IDictionary<int, string> AdditionalInformation { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Additional Information"},
					};

				public static IDictionary<int, string> FuelBillFrequency { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Fuel Bill Frequency"},
					};

				public static IDictionary<int, string> Ref { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Ref"},
					};

				public static IDictionary<int, string> Scheme { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Scheme"},
					};

				public static IDictionary<int, string> Sector { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Sector"},
					};

				public static IDictionary<int, string> Site { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Site"},
					};

				public static IDictionary<int, string> SubmissionId { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Submission"},
					};

				public static IDictionary<int, string> CreatedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By"},
					};

				public static IDictionary<int, string> CreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created On"},
					};

				public static IDictionary<int, string> CreatedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Created By (Delegate)"},
					};

				public static IDictionary<int, string> ImportSequenceNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Import Sequence Number"},
					};

				public static IDictionary<int, string> ModifiedBy { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By"},
					};

				public static IDictionary<int, string> ModifiedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified On"},
					};

				public static IDictionary<int, string> ModifiedByDelegate { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Modified By (Delegate)"},
					};

				public static IDictionary<int, string> RecordCreatedOn { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Record Created On"},
					};

				public static IDictionary<int, string> Owner { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owner"},
					};

				public static IDictionary<int, string> OwningBusinessUnit { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Business Unit"},
					};

				public static IDictionary<int, string> OwningTeam { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning Team"},
					};

				public static IDictionary<int, string> OwningUser { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Owning User"},
					};

				public static IDictionary<int, string> Status { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status"},
					};

				public static IDictionary<int, string> StatusReason { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Status Reason"},
					};

				public static IDictionary<int, string> TimeZoneRuleVersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Time Zone Rule Version Number"},
					};

				public static IDictionary<int, string> UTCConversionTimeZoneCode { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "UTC Conversion Time Zone Code"},
					};

				public static IDictionary<int, string> VersionNumber { get; set; } =
					new Dictionary<int, string>
					{
						{ 1033, "Version Number"},
					};

			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
				public const string BoilersOfSubmission = "chpqa_Boiler_chpqa_Submission_chpqa_Submi";
				public const string DiagramsOfSubmission = "chpqa_Diagram_chpqa_Submission_chpqa_Subm";
				public const string MetersOfSubmission = "chpqa_Meter_chpqa_Submission_chpqa_Submis";
				public const string PrimeMoversOfSubmission = "chpqa_PrimeMover_chpqa_Submission_chpqa_S";
			}
			
			public static class NToOne
			{
				public const string SchemeAsScheme = "chpqa_chpqa_submission_Scheme_chpqa_scheme";

				public static class Lookups
				{
					public const string SchemeAsScheme = "chpqa_scheme";
				}
			}

			public static class NToN
			{

			}
		}

		#endregion

		#endregion
	}

	#endregion

	public class GlobalEnums
	{
		public enum MeterType
		{
			[EnumMember]Fuel = 303150000,
			[EnumMember]Electricity = 303150001,
			[EnumMember]Heat = 303150002,
		}

		public enum MeterOutputUnit
		{
			[EnumMember]KWh = 709570000,
			[EnumMember]MWh = 709570001,
			[EnumMember]Cubicmeters = 303150001,
			[EnumMember]Litres = 303150002,
			[EnumMember]Kg = 303150003,
		}

		public enum HeatType
		{
			[EnumMember]SuppliedSite = 709570000,
		}

		public enum PowerOutputType
		{
			[EnumMember]Generated = 709570000,
			[EnumMember]Exported = 709570001,
			[EnumMember]Imported = 709570002,
		}

		public enum FuelBillFrequency
		{
			[EnumMember]Monthly = 709570000,
			[EnumMember]Quarterly = 709570001,
			[EnumMember]Annually = 709570002,
			[EnumMember]Other = 709570003,
		}

		public enum Sector
		{
			[EnumMember]Chemicalindustry = 709570000,
			[EnumMember]Commerce = 709570001,
			[EnumMember]Construction = 709570002,
			[EnumMember]Electricalandinstrumentengineering = 709570003,
			[EnumMember]Extractionminingandagglomeration = 709570004,
			[EnumMember]Foodbeveragesandtobacco = 709570005,
			[EnumMember]Health = 303150001,
			[EnumMember]Ironandsteel = 709570006,
			[EnumMember]Mechanicalengineeringandmetalproducts = 709570007,
			[EnumMember]Mineralproductsegglasscementbricks = 709570008,
			[EnumMember]Nonferrousmetals = 709570009,
			[EnumMember]Oilrefineries = 709570010,
			[EnumMember]Otherindustrialbranches = 709570011,
			[EnumMember]Paperpublishingandprinting = 709570012,
			[EnumMember]Powergeneration = 709570013,
			[EnumMember]PublicAdministration = 709570014,
			[EnumMember]Sewagetreatment = 709570015,
			[EnumMember]Textilesclothingandfootwear = 709570016,
			[EnumMember]Transport = 709570017,
			[EnumMember]Vehicles = 709570018,
			[EnumMember]Other = 709570019,
		}

	}

	#region Base code
		
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Class)]
	public class CrmEntityMappingAttribute : Attribute
	{
		public string LogicalName { get; private set; }
		public string SchemaName { get; private set; }
		public string DisplayName { get; private set; }

		public CrmEntityMappingAttribute(string logicalName, string schemaName, string displayName = null)
		{
			if (string.IsNullOrWhiteSpace(logicalName))
			{
				throw new ArgumentNullException("logicalName");
			}

			if (string.IsNullOrWhiteSpace(schemaName))
			{
				throw new ArgumentNullException("schemaName");
			}

			LogicalName = logicalName;
			SchemaName = schemaName;
			DisplayName = displayName;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
	public class ReadOnlyFieldAttribute : Attribute
	{}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
	public class CrmFieldMappingAttribute : Attribute
	{
		public string LogicalName { get; private set; }
		public string RelatedEntity { get; private set; }

		public CrmFieldMappingAttribute(string logicalName, string relatedEntity = null)
		{
			if (string.IsNullOrWhiteSpace(logicalName))
			{
				throw new ArgumentNullException("logicalName");
			}

			LogicalName = logicalName;
			RelatedEntity = relatedEntity;
		}
	}

	[DataContract]
	public enum EntityRelationRole
	{
		/// <summary>Specifies that the entity is the referencing entity. Value = 0.</summary>
		[EnumMember] Referencing,
		/// <summary>Specifies that the entity is the referenced entity. Value = 1.</summary>
		[EnumMember] Referenced,
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
	public class CrmRelationMappingAttribute : Attribute
	{
		public string SchemaName { get; private set; }
		public string RelatedEntityName { get; private set; }
		public EntityRelationRole? Role { get; private set; }

		public CrmRelationMappingAttribute(string schemaName, string relatedEntityName)
		{
			if (string.IsNullOrWhiteSpace(schemaName))
			{
				throw new ArgumentNullException("schemaName");
			}

			if (relatedEntityName == null)
			{
				throw new ArgumentNullException("relatedEntityName");
			}

			SchemaName = schemaName;
			RelatedEntityName = relatedEntityName;
		}

		public CrmRelationMappingAttribute(string schemaName, string relatedEntityName, EntityRelationRole role)
		{
			if (string.IsNullOrWhiteSpace(schemaName))
			{
				throw new ArgumentNullException("schemaName");
			}

			if (relatedEntityName == null)
			{
				throw new ArgumentNullException("relatedEntityName");
			}

			SchemaName = schemaName;
			RelatedEntityName = relatedEntityName;
			Role = role;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property)]
	public class MaxWidth : Attribute
	{
		public short Width { get; set; }

		public MaxWidth(short width)
		{
			Width = width;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property)]
	public class MaxHeight : Attribute
	{
		public short Height { get; set; }

		public MaxHeight(short height)
		{
			Height = height;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public class OptionsetLanguageLabel
	{
		public int LanguageCode { get; set; }
		public string OptionsetLabel {get; set;}
	}

	public enum ClearMode
	{
		[EnumMember] Disabled,
		[EnumMember] Empty,
		[EnumMember] Convention,
		[EnumMember] Flag
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property)]
	public class LabelAttribute : Attribute
	{
		public string LabelFieldNames { get; set; }
		public string LogicalName { get; set; }
		public string IdFieldName { get; set; }
		public string FieldLogicalName { get; set; }

		public LabelAttribute(string labelFieldNames, string logicalName, string idFieldName, string fieldLogicalName)
		{
			LabelFieldNames = labelFieldNames;
			LogicalName = logicalName;
			IdFieldName = idFieldName;
			FieldLogicalName = fieldLogicalName;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract]
	public class LookupValue
	{
		public LookupEntity Entity
		{
			get
			{
				LookupEntity value;
				return Enum.TryParse(EntityName, true, out value) ? value : LookupEntity.Unknown;
			}
			set => EntityName = value.ToString().ToLower();
		}

		public string EntityName
		{
			get => entityName;
			set
			{
				if (value == null) { throw new ArgumentNullException(nameof(EntityName)); }
				entityName = value;
			}
		}
		private string entityName;

		public Guid Id { get; set; }

		public LookupValue()
		{ }

		public LookupValue(string entityName, Guid id)
		{
			EntityName = entityName;
			Id = id;
		}

		public LookupValue(LookupEntity entity, Guid id)
		{
			Entity = entity;
			Id = id;
		}
	}

	public enum LookupEntity
	{
		[EnumMember] Unknown,
		[EnumMember] Account,
		[EnumMember] Contact,
		[EnumMember] User,
		[EnumMember] Team
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public static partial class CrmGeneratorExtensions
	{
		/// <summary>
		/// Retrieves the label of the 'OptionSetValue' using the corresponding enum member constant
		/// and the language code given.
		/// </summary>
		/// <param name="enumMember">The early-bound enum member constant; e.g.: 'Account.Enums.IndustryCode.Accounting'</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns>The label corresponding to the enum constant and the language code.</returns>
		public static string GetLabel(this Enum enumMember, int languageCode = 1033)
		{
			var enumType = enumMember.GetType();
			var enumName = enumType.Name.Substring(0, enumType.Name.LastIndexOf("Enum"));
			var enumParentType = enumType.DeclaringType;

			if (enumParentType == null)
			{
				return null;
			}

			var enumsType = enumParentType.GetNestedType("Enums");
			Type labelsType;

			var isContract = false;

			if (enumsType == null)
			{
				labelsType = enumParentType.Assembly.GetType($"{enumParentType.Namespace}.{enumParentType.Name}Labels", false);
				isContract = true;
			}
			else
            {
				labelsType = enumsType.GetNestedType("Labels");
			}

			if (labelsType == null)
			{
				return null;
			}

			PropertyInfo property;

			if (isContract)
            {
				property = labelsType.GetProperty($"{enumName}Enum");
			}
			else
            {
				property = labelsType.GetProperty(enumName);
			}

			if (property == null)
			{
				return null;
			}

			IDictionary<int, string> labels = null;
			IDictionary<int, IDictionary<int, string>> locLabels;

			if (isContract)
			{
				locLabels = property.GetValue(Activator.CreateInstance(labelsType)) as IDictionary<int, IDictionary<int, string>>;
			}
			else
			{
				locLabels = property.GetValue(labelsType) as IDictionary<int, IDictionary<int, string>>;
			}

			if (locLabels?.TryGetValue(languageCode, out labels) != true)
            {
				return null;
			}

			if (labels.TryGetValue((int)Enum.Parse(enumType, enumMember.ToString()), out var label) != true)
            {
				return null;
			}

			return label;
		}

	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract]
	public partial class EntityContract
	{
		[DataMember] public virtual ClearMode? ValueClearMode { get { return ClearMode.Disabled; } set{} }
	}


	#endregion

}

